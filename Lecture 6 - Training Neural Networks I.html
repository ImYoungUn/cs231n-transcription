<html>
	<head>
		<link rel="stylesheet" href="css/style.css">
		<script>
			var url="https://www.youtube.com/watch?v=wEoyxE0GP2M&list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv&index=6"
		</script>
		<script src="js/script.js"></script>
	</head>
	<body>
		<div>
<h1>Lecture 6 - Training Neural Networks I</h1>
<br/>
<p>Okay, let's get started. <span onclick="goVideo(this)" class="timestamp">00:11</span></p>
<p>Okay, so today we're going to get into some of the details about how we train neural networks. <span onclick="goVideo(this)" class="timestamp">00:16</span></p>
<p>So, some administrative details first. <span onclick="goVideo(this)" class="timestamp">00:23</span></p>
<p>Assignment 1 is due today, Thursday, so p.m. <span onclick="goVideo(this)" class="timestamp">00:26</span></p>
<p>tonight on Canvas.</p>
<p>We're also going to be releasing Assignment 2 today, and then your project proposals are due Tuesday, April 25th. <span onclick="goVideo(this)" class="timestamp">00:33</span></p>
<p>So you should be really starting to think about your projects now if you haven't already. <span onclick="goVideo(this)" class="timestamp">00:40</span></p>
<p>How many people have decided what they want to do for their project so far? <span onclick="goVideo(this)" class="timestamp">00:47</span></p>
<p>Okay, so some, some people, so yeah, everyone else, you can go to TA office hours if you want suggestions and bounce ideas off of TAs. <span onclick="goVideo(this)" class="timestamp">00:53</span></p>
<p>We also have a list of projects that other people have proposed. <span onclick="goVideo(this)" class="timestamp">01:06</span></p>
<p>Some people usually affiliated with Stanford, so on Piazza, so you can take a look at those for additional ideas. <span onclick="goVideo(this)" class="timestamp">01:11</span></p>
<p>And we also have some notes on backprop for a linear layer and a vector and tensor derivatives that Justin's written up, so that should help with understanding how exactly backprop works and for vectors and matrices. <span onclick="goVideo(this)" class="timestamp">01:20</span></p>
<p>So these are linked to lecture four on the syllabus and you can go and take a look at those. <span onclick="goVideo(this)" class="timestamp">01:34</span></p>
<p>Okay, so where we are now. <span onclick="goVideo(this)" class="timestamp">01:45</span></p>
<p>We've talked about how to express a function in terms of a computational graph, that we can represent any function in terms of a computational graph. <span onclick="goVideo(this)" class="timestamp">01:48</span></p>
<p>And we've talked more explicitly about neural networks, which is a type of graph where we have these linear layers that we stack on top of each other with nonlinearities in between. <span onclick="goVideo(this)" class="timestamp">01:57</span></p>
<p>And we've also talked last lecture about convolutional neural networks, which are a particular type of network that uses convolutional layers to preserve the spatial structure throughout all the the hierarchy of the network. <span onclick="goVideo(this)" class="timestamp">02:10</span></p>
<p>And so we saw exactly how a convolution layer looked, where each activation map in the convolutional layer output is produced by sliding a filter of weights over all of the spatial locations in the input. <span onclick="goVideo(this)" class="timestamp">02:25</span></p>
<p>And we also saw that usually we can have many filters per layer, each of which produces a separate activation map. <span onclick="goVideo(this)" class="timestamp">02:38</span></p>
<p>And so what we can get is from an input right, with a certain depth, we'll get an activation map output, which has some spatial dimension that's preserved, as well as the depth is the total number of filters that we have in that layer. <span onclick="goVideo(this)" class="timestamp">02:46</span></p>
<p>And so what we want to do is we want to learn the values of all of these weights or parameters, and we saw that we can learn our network parameters through optimization, which we talked about little bit earlier in the course, right? <span onclick="goVideo(this)" class="timestamp">03:00</span></p>
<p>And so we want to get to a point in the loss landscape that produces a low loss, and we can do this by taking steps in the direction of the negative gradient. <span onclick="goVideo(this)" class="timestamp">03:13</span></p>
<p>And so the whole process we actually call a Mini-batch Stochastic Gradient Descent where the steps are that we continuously, we sample a batch of data. <span onclick="goVideo(this)" class="timestamp">03:23</span></p>
<p>We forward prop it through our computational graph or our neural network. <span onclick="goVideo(this)" class="timestamp">03:33</span></p>
<p>We get the loss at the end. <span onclick="goVideo(this)" class="timestamp">03:37</span></p>
<p>We backprop through our network to calculate the gradients. <span onclick="goVideo(this)" class="timestamp">03:39</span></p>
<p>And then we update the parameters or the weights in our network using this gradient. <span onclick="goVideo(this)" class="timestamp">03:42</span></p>
<p>Okay, so now for the next couple of lectures we're going to talk about some of the details involved in training neural networks. <span onclick="goVideo(this)" class="timestamp">03:50</span></p>
<p>And so this involves things like how do we set up our neural network at the beginning, which activation functions that we choose, how do we preprocess the data, weight initialization, regularization, gradient checking. <span onclick="goVideo(this)" class="timestamp">03:58</span></p>
<p>We'll also talk about training dynamics. <span onclick="goVideo(this)" class="timestamp">04:11</span></p>
<p>So, how do we babysit the learning process? <span onclick="goVideo(this)" class="timestamp">04:14</span></p>
<p>How do we choose how we do parameter updates, specific perimeter update rules, and how do we do hyperparameter optimization to choose the best hyperparameters? <span onclick="goVideo(this)" class="timestamp">04:16</span></p>
<p>And then we'll also talk about evaluation and model ensembles. <span onclick="goVideo(this)" class="timestamp">04:26</span></p>
<p>So today in the first part, I will talk about activation functions, data preprocessing, weight initialization, batch normalization, babysitting the learning process, and hyperparameter optimization. <span onclick="goVideo(this)" class="timestamp">04:33</span></p>
<p>Okay, so first activation functions. <span onclick="goVideo(this)" class="timestamp">04:47</span></p>
<p>So, we saw earlier how out of any particular layer, we have the data coming in. <span onclick="goVideo(this)" class="timestamp">04:52</span></p>
<p>We multiply by our weight in you know, fully connected or a convolutional layer. <span onclick="goVideo(this)" class="timestamp">04:57</span></p>
<p>And then we'll pass this through an activation function or nonlinearity. <span onclick="goVideo(this)" class="timestamp">05:02</span></p>
<p>And we saw some examples of this. <span onclick="goVideo(this)" class="timestamp">05:06</span></p>
<p>We used sigmoid previously in some of our examples. <span onclick="goVideo(this)" class="timestamp">05:08</span></p>
<p>We also saw the ReLU nonlinearity. <span onclick="goVideo(this)" class="timestamp">05:11</span></p>
<p>And so today we'll talk more about different choices for these different nonlinearities and trade-offs between them. <span onclick="goVideo(this)" class="timestamp">05:13</span></p>
<p>So first, the sigmoid, which we've seen before, and probably the one we're most comfortable with, right? <span onclick="goVideo(this)" class="timestamp">05:22</span></p>
<p>So the sigmoid function is as we have up here, one over one plus e to the negative x. <span onclick="goVideo(this)" class="timestamp">05:27</span></p>
<p>And what this does is it takes each number that's input into the sigmoid nonlinearity, so each element, and the elementwise squashes these into this range [0,1] right, using this function here. <span onclick="goVideo(this)" class="timestamp">05:33</span></p>
<p>And so, if you get very high values as input, then output is going to be something near one. <span onclick="goVideo(this)" class="timestamp">05:45</span></p>
<p>If you get very low values, or, I'm sorry, very negative values, it's going to be near zero. <span onclick="goVideo(this)" class="timestamp">05:51</span></p>
<p>And then we have this regime near zero that it's in a linear regime. <span onclick="goVideo(this)" class="timestamp">05:55</span></p>
<p>It looks a bit like a linear function. <span onclick="goVideo(this)" class="timestamp">06:00</span></p>
<p>And so this is been historically popular, because sigmoids, in a sense, you can interpret them as a kind of a saturating firing rate of a neuron, right? <span onclick="goVideo(this)" class="timestamp">06:03</span></p>
<p>So if it's something between zero and one, you could think of it as a firing rate. <span onclick="goVideo(this)" class="timestamp">06:12</span></p>
<p>And we'll talk later about other nonlinearities, like ReLUs that, in practice, actually turned out to be more biologically plausible, but this does have a kind of interpretation that you could make. <span onclick="goVideo(this)" class="timestamp">06:16</span></p>
<p>So if we look at this nonlinearity more carefully, there's several problems that there actually are with this. <span onclick="goVideo(this)" class="timestamp">06:30</span></p>
<p>So the first is that saturated neurons can kill off the gradient. <span onclick="goVideo(this)" class="timestamp">06:37</span></p>
<p>And so what exactly does this mean? <span onclick="goVideo(this)" class="timestamp">06:41</span></p>
<p>So if we look at a sigmoid gate right, a node in our computational graph, and we have our data X as input into it, and then we have the output of the sigmoid gate coming out of it, what does the gradient flow look like as we're coming back? <span onclick="goVideo(this)" class="timestamp">06:45</span></p>
<p>We have dL over d sigma right? <span onclick="goVideo(this)" class="timestamp">06:59</span></p>
<p>The upstream gradient coming down, and then we're going to multiply this by dSigma over dX. <span onclick="goVideo(this)" class="timestamp">07:02</span></p>
<p>This will be the gradient of a local sigmoid function. <span onclick="goVideo(this)" class="timestamp">07:09</span></p>
<p>And we're going to chain these together for our downstream gradient that we pass back. <span onclick="goVideo(this)" class="timestamp">07:11</span></p>
<p>So who can tell me what happens when X is equal to -10? <span onclick="goVideo(this)" class="timestamp">07:17</span></p>
<p>It's very negative. <span onclick="goVideo(this)" class="timestamp">07:21</span></p>
<p>What does is gradient look like? <span onclick="goVideo(this)" class="timestamp">07:22</span></p>
<p>Zero, yeah, so that's right. <span onclick="goVideo(this)" class="timestamp">07:25</span></p>
<p>So the gradient become zero and that's because in this negative, very negative region of the sigmoid, it's essentially flat, so the gradient is zero, and we chain any upstream gradient coming down. <span onclick="goVideo(this)" class="timestamp">07:27</span></p>
<p>We multiply by basically something near zero, and we're going to get a very small gradient that's flowing back downwards, right? <span onclick="goVideo(this)" class="timestamp">07:40</span></p>
<p>So, in a sense, after the chain rule, this kills the gradient flow and you're going to have a zero gradient passed down to downstream nodes. <span onclick="goVideo(this)" class="timestamp">07:47</span></p>
<p>And so what happens when X is equal to zero? <span onclick="goVideo(this)" class="timestamp">07:59</span></p>
<p>So there it's, yeah, it's fine in this regime. <span onclick="goVideo(this)" class="timestamp">08:05</span></p>
<p>So, in this regime near zero, you're going to get a reasonable gradient here, and then it'll be fine for backprop. <span onclick="goVideo(this)" class="timestamp">08:08</span></p>
<p>And then what about X equals 10? <span onclick="goVideo(this)" class="timestamp">08:15</span></p>
<p>Zero, right. <span onclick="goVideo(this)" class="timestamp">08:19</span></p>
<p>So again, so when X is equal to a very negative or X is equal to large positive numbers, then these are all regions where the sigmoid function is flat, and it's going to kill off the gradient and you're not going to get a gradient flow coming back. <span onclick="goVideo(this)" class="timestamp">08:20</span></p>
<p>Okay, so a second problem is that the sigmoid outputs are not zero centered. <span onclick="goVideo(this)" class="timestamp">08:37</span></p>
<p>And so let's take a look at why this is a problem. <span onclick="goVideo(this)" class="timestamp">08:43</span></p>
<p>So, consider what happens when the input to a neuron is always positive. <span onclick="goVideo(this)" class="timestamp">08:47</span></p>
<p>So in this case, all of our Xs we're going to say is positive. <span onclick="goVideo(this)" class="timestamp">08:52</span></p>
<p>It's going to be multiplied by some weight, W, and then we're going to run it through our activation function. <span onclick="goVideo(this)" class="timestamp">08:55</span></p>
<p>So what can we say about the gradients on W? <span onclick="goVideo(this)" class="timestamp">09:04</span></p>
<p>So think about what the local gradient is going to be, right, for this linear layer. <span onclick="goVideo(this)" class="timestamp">09:12</span></p>
<p>We have DL over whatever the activation function, the loss coming down, and then we have our local gradient, which is going to be basically X, right? <span onclick="goVideo(this)" class="timestamp">09:18</span></p>
<p>And so what does this mean, if all of X is positive? <span onclick="goVideo(this)" class="timestamp">09:30</span></p>
<p>Okay, so I heard it's always going to be positive. <span onclick="goVideo(this)" class="timestamp">09:36</span></p>
<p>So that's almost right. <span onclick="goVideo(this)" class="timestamp">09:39</span></p>
<p>It's always going to be either positive, or all positive or all negative, right? <span onclick="goVideo(this)" class="timestamp">09:40</span></p>
<p>So, our upstream gradient coming down is DL over our loss. <span onclick="goVideo(this)" class="timestamp">09:45</span></p>
<p>L is going to be DL over DF. <span onclick="goVideo(this)" class="timestamp">09:50</span></p>
<p>and this is going to be either positive or negative. <span onclick="goVideo(this)" class="timestamp">09:52</span></p>
<p>It's some arbitrary gradient coming down. <span onclick="goVideo(this)" class="timestamp">09:54</span></p>
<p>And then our local gradient that we multiply this by is, if we're going to find the gradients on W, is going to be DF over DW, which is going to be X. <span onclick="goVideo(this)" class="timestamp">09:56</span></p>
<p>And if X is always positive then the gradients on W, which is multiplying these two together, are going to always be the sign of the upstream gradient coming down. <span onclick="goVideo(this)" class="timestamp">10:08</span></p>
<p>And so what this means is that all the gradients of W, since they're always either positive or negative, they're always going to move in the same direction. <span onclick="goVideo(this)" class="timestamp">10:21</span></p>
<p>You're either going to increase all of the, when you do a parameter update, you're going to either increase all of the values of W by a positive amount, or differing positive amounts, or you will decrease them all. <span onclick="goVideo(this)" class="timestamp">10:29</span></p>
<p>And so the problem with this is that, this gives very inefficient gradient updates. <span onclick="goVideo(this)" class="timestamp">10:43</span></p>
<p>So, if you look at on the right here, we have an example of a case where, let's say W is two-dimensional, so we have our two axes for W, and if we say that we can only have all positive or all negative updates, then we have these two quadrants, and, are the two places where the axis are either all positive or negative, and these are the only directions in which we're allowed to make a gradient update. <span onclick="goVideo(this)" class="timestamp">10:49</span></p>
<p>And so in the case where, let's say our hypothetical optimal W is actually this blue vector here, right, and we're starting off at you know some point, or at the top of the the the beginning of the red arrows, we can't just directly take a gradient update in this direction, because this is not in one of those two allowed gradient directions. <span onclick="goVideo(this)" class="timestamp">11:17</span></p>
<p>And so what we're going to have to do, is we'll have to take a sequence of gradient updates. <span onclick="goVideo(this)" class="timestamp">11:39</span></p>
<p>For example, in these red arrow directions that are each in allowed directions, in order to finally get to this optimal W. <span onclick="goVideo(this)" class="timestamp">11:44</span></p>
<p>And so this is why also, in general, we want a zero mean data. <span onclick="goVideo(this)" class="timestamp">11:53</span></p>
<p>So, we want our input X to be zero meaned, so that we actually have positive and negative values and we don't get into this problem of the gradient updates. <span onclick="goVideo(this)" class="timestamp">11:59</span></p>
<p>They'll be all moving in the same direction. <span onclick="goVideo(this)" class="timestamp">12:09</span></p>
<p>So is this clear? <span onclick="goVideo(this)" class="timestamp">12:12</span></p>
<p>Any questions on this point? <span onclick="goVideo(this)" class="timestamp">12:13</span></p>
<p>Okay. <span onclick="goVideo(this)" class="timestamp">12:17</span></p>
<p>Okay, so we've talked about these two main problems of the sigmoid. <span onclick="goVideo(this)" class="timestamp">12:22</span></p>
<p>The saturated neurons can kill the gradients if we're too positive or too negative of an input. <span onclick="goVideo(this)" class="timestamp">12:25</span></p>
<p>They're also not zero-centered and so we get these, this inefficient kind of gradient update. <span onclick="goVideo(this)" class="timestamp">12:31</span></p>
<p>And then a third problem, we have an exponential function in here, so this is a little bit computationally expensive. <span onclick="goVideo(this)" class="timestamp">12:37</span></p>
<p>In the grand scheme of your network, this is usually not the main problem, because we have all these convolutions and dot products that are a lot more expensive, but this is just a minor point also to observe. <span onclick="goVideo(this)" class="timestamp">12:43</span></p>
<p>So now we can look at a second activation function here at tanh. <span onclick="goVideo(this)" class="timestamp">12:59</span></p>
<p>And so this looks very similar to the sigmoid, but the difference is that now it's squashing to the range [-1, 1]. <span onclick="goVideo(this)" class="timestamp">13:03</span></p>
<p>So here, the main difference is that it's now zero-centered, so we've gotten rid of the second problem that we had. <span onclick="goVideo(this)" class="timestamp">13:11</span></p>
<p>It still kills the gradients, however, when it's saturated. <span onclick="goVideo(this)" class="timestamp">13:18</span></p>
<p>So, you still have these regimes where the gradient is essentially flat and you're going to kill the gradient flow. <span onclick="goVideo(this)" class="timestamp">13:21</span></p>
<p>So this is a bit better than the sigmoid, but it still has some problems. <span onclick="goVideo(this)" class="timestamp">13:29</span></p>
<p>Okay, so now let's look at the ReLU activation function. <span onclick="goVideo(this)" class="timestamp">13:37</span></p>
<p>And this is one that we saw in our examples last lecture when we were talking about the convolutional neural network. <span onclick="goVideo(this)" class="timestamp">13:40</span></p>
<p>And we saw that we interspersed ReLU nonlinearities between many of the convolutional layers. <span onclick="goVideo(this)" class="timestamp">13:48</span></p>
<p>And so, this function is f of x equals max of zero and x. <span onclick="goVideo(this)" class="timestamp">13:53</span></p>
<p>So it takes an elementwise operation on your input and basically if your input is negative, it's going to put it to zero. <span onclick="goVideo(this)" class="timestamp">13:58</span></p>
<p>And then if it's positive, it's going to be just passed through. <span onclick="goVideo(this)" class="timestamp">14:07</span></p>
<p>It's the identity. <span onclick="goVideo(this)" class="timestamp">14:11</span></p>
<p>And so this is one that's pretty commonly used, and if we look at this one and look at and think about the problems that we saw earlier with the sigmoid and the tanh, we can see that it doesn't saturate in the positive region. <span onclick="goVideo(this)" class="timestamp">14:13</span></p>
<p>So there's whole half of our input space where it's not going to saturate, so this is a big advantage. <span onclick="goVideo(this)" class="timestamp">14:27</span></p>
<p>So this is also computationally very efficient. <span onclick="goVideo(this)" class="timestamp">14:35</span></p>
<p>We saw earlier that the sigmoid has this E exponential in it. <span onclick="goVideo(this)" class="timestamp">14:37</span></p>
<p>And so the ReLU is just this simple max and there's, it's extremely fast. <span onclick="goVideo(this)" class="timestamp">14:43</span></p>
<p>And in practice, using this ReLU, it converges much faster than the sigmoid and the tanh, so about six times faster. <span onclick="goVideo(this)" class="timestamp">14:49</span></p>
<p>And it's also turned out to be more biologically plausible than the sigmoid. <span onclick="goVideo(this)" class="timestamp">14:57</span></p>
<p>So if you look at a neuron and you look at what the inputs look like, and you look at what the outputs look like, and you try to measure this in neuroscience experiments, you'll see that this one is actually a closer approximation to what's happening than sigmoids. <span onclick="goVideo(this)" class="timestamp">15:01</span></p>
<p>And so ReLUs were starting to be used a lot around 2012 when we had AlexNet, the first major convolutional neural network that was able to do well on ImageNet and large-scale data. <span onclick="goVideo(this)" class="timestamp">15:18</span></p>
<p>They used the ReLU in their experiments. <span onclick="goVideo(this)" class="timestamp">15:31</span></p>
<p>So a problem however, with the ReLU, is that it's still, it's not not zero-centered anymore. <span onclick="goVideo(this)" class="timestamp">15:37</span></p>
<p>So we saw that the sigmoid was not zero-centered. <span onclick="goVideo(this)" class="timestamp">15:42</span></p>
<p>Tanh fixed this and now ReLU has this problem again. <span onclick="goVideo(this)" class="timestamp">15:45</span></p>
<p>And so that's one of the issues of the ReLU. <span onclick="goVideo(this)" class="timestamp">15:49</span></p>
<p>And then we also have this further annoyance of, again we saw that in the positive half of the inputs, we don't have saturation, but this is not the case of the negative half. <span onclick="goVideo(this)" class="timestamp">15:52</span></p>
<p>Right, so just thinking about this a little bit more precisely. <span onclick="goVideo(this)" class="timestamp">16:04</span></p>
<p>So what's happening here when X equals negative 10? <span onclick="goVideo(this)" class="timestamp">16:07</span></p>
<p>So zero gradient, that's right. <span onclick="goVideo(this)" class="timestamp">16:11</span></p>
<p>What happens when X is equal to positive 10? <span onclick="goVideo(this)" class="timestamp">16:13</span></p>
<p>It's good, right. <span onclick="goVideo(this)" class="timestamp">16:18</span></p>
<p>So, we're in the linear regime. <span onclick="goVideo(this)" class="timestamp">16:18</span></p>
<p>And then what happens when X is equal to zero? <span onclick="goVideo(this)" class="timestamp">16:20</span></p>
<p>Yes, it undefined here, but in practice, we'll say, you know, zero, right. <span onclick="goVideo(this)" class="timestamp">16:26</span></p>
<p>And so basically, it's killing the gradient in half of the regime. <span onclick="goVideo(this)" class="timestamp">16:31</span></p>
<p>And so we can get this phenomenon of basically dead ReLUs, when we're in this bad part of the regime. <span onclick="goVideo(this)" class="timestamp">16:38</span></p>
<p>And so there's, you can look at this in, as coming from several potential reasons. <span onclick="goVideo(this)" class="timestamp">16:46</span></p>
<p>And so if we look at our data cloud here, this is all of our training data, then if we look at where the ReLUs can fall, so the ReLUs can be, each of these is basically the half of the plane where it's going to activate. <span onclick="goVideo(this)" class="timestamp">16:51</span></p>
<p>And so each of these is the plane that defines each of these ReLUs, and we can see that you can have these dead ReLUs that are basically off of the data cloud. <span onclick="goVideo(this)" class="timestamp">17:12</span></p>
<p>And in this case, it will never activate and never update, as compared to an active ReLU where some of the data is going to be positive and passed through and some won't be. <span onclick="goVideo(this)" class="timestamp">17:21</span></p>
<p>And so there's several reasons for this. <span onclick="goVideo(this)" class="timestamp">17:32</span></p>
<p>The first is that it can happen when you have bad initialization. <span onclick="goVideo(this)" class="timestamp">17:34</span></p>
<p>So if you have weights that happen to be unlucky and they happen to be off the data cloud, so they happen to specify this bad ReLU over here. <span onclick="goVideo(this)" class="timestamp">17:37</span></p>
<p>Then they're never going to get a data input that causes it to activate, and so they're never going to get good gradient flow coming back. <span onclick="goVideo(this)" class="timestamp">17:45</span></p>
<p>And so it'll just never update and never activate. <span onclick="goVideo(this)" class="timestamp">17:56</span></p>
<p>What's the more common case is when your learning rate is too high. <span onclick="goVideo(this)" class="timestamp">17:59</span></p>
<p>And so this case you started off with an okay ReLU, but because you're making these huge updates, the weights jump around and then your ReLU unit in a sense, gets knocked off of the data manifold. <span onclick="goVideo(this)" class="timestamp">18:04</span></p>
<p>And so this happens through training. <span onclick="goVideo(this)" class="timestamp">18:16</span></p>
<p>So it was fine at the beginning and then at some point, it became bad and it died. <span onclick="goVideo(this)" class="timestamp">18:18</span></p>
<p>And so if in practice, if you freeze a network that you've trained and you pass the data through, you can see it actually is much as 10 to 20% of the network is these dead ReLUs. <span onclick="goVideo(this)" class="timestamp">18:23</span></p>
<p>And so you know that's a problem, but also most networks do have this type of problem when you use ReLUs. <span onclick="goVideo(this)" class="timestamp">18:33</span></p>
<p>Some of them will be dead, and in practice, people look into this, and it's a research problem, but it's still doing okay for training networks. <span onclick="goVideo(this)" class="timestamp">18:40</span></p>
<p>Yeah, is there a question? <span onclick="goVideo(this)" class="timestamp">18:50</span></p>
<p>[student speaking off mic] Right. <span onclick="goVideo(this)" class="timestamp">18:51</span></p>
<p>So the question is, yeah, so the data cloud is just your training data. <span onclick="goVideo(this)" class="timestamp">19:03</span></p>
<p>[student speaking off mic] Okay, so the question is when, how do you tell when the ReLU is going to be dead or not, with respect to the data cloud? <span onclick="goVideo(this)" class="timestamp">19:05</span></p>
<p>And so if you look at, this is an example of like a simple two-dimensional case. <span onclick="goVideo(this)" class="timestamp">19:26</span></p>
<p>And so our ReLU, we're going to get our input to the ReLU, which is going to be a basically you know, W1 X1 plus W2 X2, and it we apply this, so that that defines this this separating hyperplane here, and then we're going to take half of it that's going to be positive, and half of it's going to be killed off, and so yes, so you, you know you just, it's whatever the weights happened to be, and where the data happens to be is where these, where these hyperplanes fall, and so, so yeah so just throughout the course of training, some of your ReLUs will be in different places, with respect to the data cloud. <span onclick="goVideo(this)" class="timestamp">19:31</span></p>
<p>Oh, question. <span onclick="goVideo(this)" class="timestamp">20:17</span></p>
<p>[student speaking off mic] Yeah. <span onclick="goVideo(this)" class="timestamp">20:18</span></p>
<p>So okay, so the question is for the sigmoid we talked about two drawbacks, and one of them was that the neurons can get saturated, so let's go back to the sigmoid here, and the question was this is not the case, when all of your inputs are positive. <span onclick="goVideo(this)" class="timestamp">20:28</span></p>
<p>So when all of your inputs are positive, they're all going to be coming in in this zero plus region here, and so you can still get a saturating neuron, because you see up in this positive region, it also plateaus at one, and so when it's when you have large positive values as input you're also going to get the zero gradient, because you have you have a flat slope here. <span onclick="goVideo(this)" class="timestamp">20:46</span></p>
<p>Okay. <span onclick="goVideo(this)" class="timestamp">21:11</span></p>
<p>Okay, so in practice people also like to initialize ReLUs with slightly positive biases, in order to increase the likelihood of it being active at initialization and to get some updates. <span onclick="goVideo(this)" class="timestamp">21:16</span></p>
<p>Right and so this basically just biases towards more ReLUs firing at the beginning, and in practice some say that it helps. <span onclick="goVideo(this)" class="timestamp">21:31</span></p>
<p>Some say that it doesn't. <span onclick="goVideo(this)" class="timestamp">21:38</span></p>
<p>Generally people don't always use this. <span onclick="goVideo(this)" class="timestamp">21:41</span></p>
<p>It's yeah, a lot of times people just initialize it with zero biases still. <span onclick="goVideo(this)" class="timestamp">21:43</span></p>
<p>Okay, so now we can look at some modifications on the ReLU that have come out since then, and so one example is this leaky ReLU. <span onclick="goVideo(this)" class="timestamp">21:50</span></p>
<p>And so this looks very similar to the original ReLU, and the only difference is that now instead of being flat in the negative regime, we're going to give a slight negative slope here And so this solves a lot of the problems that we mentioned earlier. <span onclick="goVideo(this)" class="timestamp">21:58</span></p>
<p>Right here we don't have any saturating regime, even in the negative space. <span onclick="goVideo(this)" class="timestamp">22:12</span></p>
<p>It's still very computationally efficient. <span onclick="goVideo(this)" class="timestamp">22:17</span></p>
<p>It still converges faster than sigmoid and tanh, very similar to a ReLU. <span onclick="goVideo(this)" class="timestamp">22:20</span></p>
<p>And it doesn't have this dying problem. <span onclick="goVideo(this)" class="timestamp">22:24</span></p>
<p>And there's also another example is the parametric rectifier, so PReLU. <span onclick="goVideo(this)" class="timestamp">22:29</span></p>
<p>And so in this case it's just like a leaky ReLU where we again have this sloped region in the negative space, but now this slope in the negative regime is determined through this alpha parameter, so we don't specify, we don't hard-code it. <span onclick="goVideo(this)" class="timestamp">22:35</span></p>
<p>but we treat it as now a parameter that we can backprop into and learn. <span onclick="goVideo(this)" class="timestamp">22:49</span></p>
<p>And so this gives it a little bit more flexibility. <span onclick="goVideo(this)" class="timestamp">22:53</span></p>
<p>And we also have something called an Exponential Linear Unit, an ELU, so we have all these different LUs, basically. <span onclick="goVideo(this)" class="timestamp">22:58</span></p>
<p>and this one again, you know, it has all the benefits of the ReLu, but now you're, it is also closer to zero mean outputs. <span onclick="goVideo(this)" class="timestamp">23:06</span></p>
<p>So, that's actually an advantage that the leaky ReLU, parametric ReLU, a lot of these they allow you to have your mean closer to zero, but compared with the leaky ReLU, instead of it being sloped in the negative regime, here you actually are building back in a negative saturation regime, and there's arguments that basically this allows you to have some more robustness to noise, and you basically get these deactivation states that can be more robust. <span onclick="goVideo(this)" class="timestamp">23:16</span></p>
<p>And you can look at this paper for, there's a lot of kind of more justification for why this is the case. <span onclick="goVideo(this)" class="timestamp">23:49</span></p>
<p>And in a sense this is kind of something in between the ReLUs and the leaky ReLUs, where has some of this shape, which the Leaky ReLU does, which gives it closer to zero mean output, but then it also still has some of this more saturating behavior that ReLUs have. <span onclick="goVideo(this)" class="timestamp">23:56</span></p>
<p>A question? <span onclick="goVideo(this)" class="timestamp">24:13</span></p>
<p>[student speaking off mic] So, whether this parameter alpha is going to be specific for each neuron. <span onclick="goVideo(this)" class="timestamp">24:14</span></p>
<p>So, I believe it is often specified, but I actually can't remember exactly, so you can look in the paper for exactly, yeah, how this is defined, but yeah, so I believe this function is basically very carefully designed in order to have nice desirable properties. <span onclick="goVideo(this)" class="timestamp">24:24</span></p>
<p>Okay, so there's basically all of these kinds of variants on the ReLU. <span onclick="goVideo(this)" class="timestamp">24:45</span></p>
<p>And so you can see that, all of these it's kind of, you can argue that each one may have certain benefits, certain drawbacks in practice. <span onclick="goVideo(this)" class="timestamp">24:50</span></p>
<p>People just want to run experiments all of them, and see empirically what works better, try and justify it, and come up with new ones, but they're all different things that are being experimented with. <span onclick="goVideo(this)" class="timestamp">24:58</span></p>
<p>And so let's just mention one more. <span onclick="goVideo(this)" class="timestamp">25:10</span></p>
<p>This is Maxout Neuron. <span onclick="goVideo(this)" class="timestamp">25:13</span></p>
<p>So, this one looks a little bit different in that it doesn't have the same form as the others did of taking your basic dot product, and then putting this element-wise nonlinearity in front of it. <span onclick="goVideo(this)" class="timestamp">25:15</span></p>
<p>Instead, it looks like this, this max of W dot product of X plus B, and a second set of weights, W2 dot product with X plus B2. <span onclick="goVideo(this)" class="timestamp">25:26</span></p>
<p>And so what does this, is this is taking the max of these two functions in a sense. <span onclick="goVideo(this)" class="timestamp">25:38</span></p>
<p>And so what it does is it generalizes the ReLU and the leaky ReLu, because you're just you're taking the max over these two, two linear functions. <span onclick="goVideo(this)" class="timestamp">25:45</span></p>
<p>And so what this give us, it's again you're operating in a linear regime. <span onclick="goVideo(this)" class="timestamp">25:55</span></p>
<p>It doesn't saturate and it doesn't die. <span onclick="goVideo(this)" class="timestamp">26:01</span></p>
<p>The problem is that here, you are doubling the number of parameters per neuron. <span onclick="goVideo(this)" class="timestamp">26:03</span></p>
<p>So, each neuron now has this original set of weights, W, but it now has W1 and W2, so you have twice these. <span onclick="goVideo(this)" class="timestamp">26:07</span></p>
<p>So in practice, when we look at all of these activation functions, kind of a good general rule of thumb is use ReLU. <span onclick="goVideo(this)" class="timestamp">26:18</span></p>
<p>This is the most standard one that generally just works well. <span onclick="goVideo(this)" class="timestamp">26:25</span></p>
<p>And you know you do want to be careful in general with your learning rates to adjust them based, see how things do. <span onclick="goVideo(this)" class="timestamp">26:30</span></p>
<p>We'll talk more about adjusting learning rates later in this lecture, but you can also try out some of these fancier activation functions, the leaky ReLU, Maxout, ELU, but these are generally, they're still kind of more experimental. <span onclick="goVideo(this)" class="timestamp">26:37</span></p>
<p>So, you can see how they work for your problem. <span onclick="goVideo(this)" class="timestamp">26:54</span></p>
<p>You can also try out tanh, but probably some of these ReLU and ReLU variants are going to be better. <span onclick="goVideo(this)" class="timestamp">26:57</span></p>
<p>And in general don't use sigmoid. <span onclick="goVideo(this)" class="timestamp">27:04</span></p>
<p>This is one of the earliest original activation functions, and ReLU and these other variants have generally worked better since then. <span onclick="goVideo(this)" class="timestamp">27:07</span></p>
<p>Okay, so now let's talk a little bit about data preprocessing. <span onclick="goVideo(this)" class="timestamp">27:17</span></p>
<p>Right, so the activation function, we design this is part of our network. <span onclick="goVideo(this)" class="timestamp">27:22</span></p>
<p>Now we want to train the network, and we have our input data that we want to start training from. <span onclick="goVideo(this)" class="timestamp">27:25</span></p>
<p>So, generally we want to always preprocess the data, and this is something that you've probably seen before in machine learning classes if you taken those. <span onclick="goVideo(this)" class="timestamp">27:32</span></p>
<p>And some standard types of preprocessing are, you take your original data and you want to zero mean them, and then you probably want to also normalize that, so normalized by the standard deviation, And so why do we want to do this? <span onclick="goVideo(this)" class="timestamp">27:40</span></p>
<p>For zero centering, you can remember earlier that we talked about when all the inputs are positive, for example, then we get all of our gradients on the weights to be positive, and we get this basically suboptimal optimization. <span onclick="goVideo(this)" class="timestamp">27:57</span></p>
<p>And in general even if it's not all zero or all negative, any sort of bias will still cause this type of problem. <span onclick="goVideo(this)" class="timestamp">28:13</span></p>
<p>And so then in terms of normalizing the data, this is basically you want to normalize data typically in the machine learning problems, so that all features are in the same range, and so that they contribute equally. <span onclick="goVideo(this)" class="timestamp">28:24</span></p>
<p>In practice, since for images, which is what we're dealing with in this course here for the most part, we do do the zero centering, but in practice we don't actually normalize the pixel value so much, because generally for images right at each location you already have relatively comparable scale and distribution, and so we don't really need to normalize so much, compared to more general machine learning problems, where you might have different features that are very different and of very different scales. <span onclick="goVideo(this)" class="timestamp">28:37</span></p>
<p>And in machine learning, you might also see a more complicated things, like PCA or whitening, but again with images, we typically just stick with the zero mean, and we don't do the normalization, and we also don't do some of these more complicated pre-processing. <span onclick="goVideo(this)" class="timestamp">29:11</span></p>
<p>And one reason for this is generally with images we don't really want to take all of our input, let's say pixel values and project this onto a lower dimensional space of new kinds of features that we're dealing with. <span onclick="goVideo(this)" class="timestamp">29:30</span></p>
<p>We typically just want to apply convolutional networks spatially and have our spatial structure over the original image. <span onclick="goVideo(this)" class="timestamp">29:41</span></p>
<p>Yeah, question. <span onclick="goVideo(this)" class="timestamp">29:48</span></p>
<p>[student speaking off mic] So the question is we do this pre-processing in a training phase, do we also do the same kind of thing in the test phase, and the answer is yes. <span onclick="goVideo(this)" class="timestamp">29:50</span></p>
<p>So, let me just move to the next slide here. <span onclick="goVideo(this)" class="timestamp">30:07</span></p>
<p>So, in general on the training phase is where we determine our let's say, mean, and then we apply this exact same mean to the test data. <span onclick="goVideo(this)" class="timestamp">30:10</span></p>
<p>So, we'll normalize by the same empirical mean from the training data. <span onclick="goVideo(this)" class="timestamp">30:20</span></p>
<p>Okay, so to summarize basically for images, we typically just do the zero mean pre-processing and we can subtract either the entire mean image. <span onclick="goVideo(this)" class="timestamp">30:25</span></p>
<p>So, from the training data, you compute the mean image, which will be the same size as your, as each image. <span onclick="goVideo(this)" class="timestamp">30:38</span></p>
<p>So, for example 32 by 32 by three, you'll get this array of numbers, and then you subtract that from each image that you're about to pass through the network, and you'll do the same thing at test time for this array that you determined at training time. <span onclick="goVideo(this)" class="timestamp">30:45</span></p>
<p>In practice, we can also for some networks, we also do this by just of subtracting a per-channel mean, and so instead of having an entire mean image that were going to zero-center by, we just take the mean by channel, and this is just because it turns out that it was similar enough across the whole image, it didn't make such a big difference to subtract the mean image versus just a per-channel value. <span onclick="goVideo(this)" class="timestamp">31:01</span></p>
<p>And this is easier to just pass around and deal with. <span onclick="goVideo(this)" class="timestamp">31:26</span></p>
<p>So, you'll see this as well for example, in a VGG Network, which is a network that came after AlexNet, and we'll talk about that later. <span onclick="goVideo(this)" class="timestamp">31:29</span></p>
<p>Question. <span onclick="goVideo(this)" class="timestamp">31:37</span></p>
<p>[student speaking off mic] Okay, so there are two questions. <span onclick="goVideo(this)" class="timestamp">31:39</span></p>
<p>The first is what's a channel, in this case, when we are subtracting a per-channel mean? <span onclick="goVideo(this)" class="timestamp">31:47</span></p>
<p>And this is RGB, so our array, our images are typically for example, 32 by 32 by three. <span onclick="goVideo(this)" class="timestamp">31:52</span></p>
<p>So, width, height, each are 32, and our depth, we have three channels RGB, and so we'll have one mean for the red channel, one mean for a green, one for blue. <span onclick="goVideo(this)" class="timestamp">32:00</span></p>
<p>And then the second, what was your second question? <span onclick="goVideo(this)" class="timestamp">32:10</span></p>
<p>[student speaking off mic] Oh. <span onclick="goVideo(this)" class="timestamp">32:15</span></p>
<p>Okay, so the question is when we're subtracting the mean image, what is the mean taken over? <span onclick="goVideo(this)" class="timestamp">32:23</span></p>
<p>And the mean is taking over all of your training images. <span onclick="goVideo(this)" class="timestamp">32:28</span></p>
<p>So, you'll take all of your training images and just compute the mean of all of those. <span onclick="goVideo(this)" class="timestamp">32:32</span></p>
<p>Does that make sense? <span onclick="goVideo(this)" class="timestamp">32:38</span></p>
<p>[student speaking off mic] Yeah the question is, we do this for the entire training set, once before we start training. <span onclick="goVideo(this)" class="timestamp">32:39</span></p>
<p>We don't do this per batch, and yeah, that's exactly correct. <span onclick="goVideo(this)" class="timestamp">32:54</span></p>
<p>So we just want to have a good sample, an empirical mean that we have. <span onclick="goVideo(this)" class="timestamp">32:58</span></p>
<p>And so if you take it per batch, if you're sampling reasonable batches, it should be basically, you should be getting the same values anyways for the mean, and so it's more efficient and easier just do this once at the beginning. <span onclick="goVideo(this)" class="timestamp">33:04</span></p>
<p>You might not even have to really take it over the entire training data. <span onclick="goVideo(this)" class="timestamp">33:19</span></p>
<p>You could also just sample enough training images to get a good estimate of your mean. <span onclick="goVideo(this)" class="timestamp">33:23</span></p>
<p>Okay, so any other questions about data preprocessing? <span onclick="goVideo(this)" class="timestamp">33:31</span></p>
<p>Yes. <span onclick="goVideo(this)" class="timestamp">33:35</span></p>
<p>[student speaking off mic] So, the question is does the data preprocessing solve the sigmoid problem? <span onclick="goVideo(this)" class="timestamp">33:36</span></p>
<p>So the data preprocessing is doing zero mean right? <span onclick="goVideo(this)" class="timestamp">33:42</span></p>
<p>And we talked about how sigmoid, we want to have zero mean. <span onclick="goVideo(this)" class="timestamp">33:48</span></p>
<p>And so it does solve this for the first layer that we pass it through. <span onclick="goVideo(this)" class="timestamp">33:51</span></p>
<p>So, now our inputs to the first layer of our network is going to be zero mean, but we'll see later on that we're actually going to have this problem come up in much worse and greater form, as we have deep networks. <span onclick="goVideo(this)" class="timestamp">33:56</span></p>
<p>You're going to get a lot of nonzero mean problems later on. <span onclick="goVideo(this)" class="timestamp">34:09</span></p>
<p>And so in this case, this is not going to be sufficient. <span onclick="goVideo(this)" class="timestamp">34:13</span></p>
<p>So this only helps at the first layer of your network. <span onclick="goVideo(this)" class="timestamp">34:15</span></p>
<p>Okay, so now let's talk about how do we want to initialize the weights of our network? <span onclick="goVideo(this)" class="timestamp">34:22</span></p>
<p>So, we have let's say our standard two layer neural network and we have all of these weights that we want to learn, but we have to start them with some value, right? <span onclick="goVideo(this)" class="timestamp">34:28</span></p>
<p>And then we're going to update them using our gradient updates from there. <span onclick="goVideo(this)" class="timestamp">34:38</span></p>
<p>So first question. <span onclick="goVideo(this)" class="timestamp">34:44</span></p>
<p>What happens when we use an initialization of W equals zero? <span onclick="goVideo(this)" class="timestamp">34:45</span></p>
<p>We just set all of the parameters to be zero. <span onclick="goVideo(this)" class="timestamp">34:49</span></p>
<p>What's the problem with this? <span onclick="goVideo(this)" class="timestamp">34:53</span></p>
<p>[student speaking off mic] So sorry, say that again. <span onclick="goVideo(this)" class="timestamp">34:56</span></p>
<p>So I heard all the neurons are going to be dead. <span onclick="goVideo(this)" class="timestamp">35:02</span></p>
<p>No updates ever. <span onclick="goVideo(this)" class="timestamp">35:06</span></p>
<p>So not exactly. <span onclick="goVideo(this)" class="timestamp">35:07</span></p>
<p>So, part of that is correct in that all the neurons will do the same thing. <span onclick="goVideo(this)" class="timestamp">35:11</span></p>
<p>So, they might not all be dead. <span onclick="goVideo(this)" class="timestamp">35:15</span></p>
<p>Depending on your input value, I mean, you could be in any regime of your neurons, so they might not be dead, but the key thing is that they will all do the same thing. <span onclick="goVideo(this)" class="timestamp">35:17</span></p>
<p>So, since your weights are zero, given an input, every neuron is going to be, have the same operation basically on top of your inputs. <span onclick="goVideo(this)" class="timestamp">35:28</span></p>
<p>And so, since they're all going to output the same thing, they're also all going to get the same gradient. <span onclick="goVideo(this)" class="timestamp">35:37</span></p>
<p>And so, because of that, they're all going to update in the same way. <span onclick="goVideo(this)" class="timestamp">35:44</span></p>
<p>And now you're just going to get all neurons that are exactly the same, which is not what you want. <span onclick="goVideo(this)" class="timestamp">35:48</span></p>
<p>You want the neurons to learn different things. <span onclick="goVideo(this)" class="timestamp">35:52</span></p>
<p>And so, that's the problem when you initialize everything equally and there's basically no symmetry breaking here. <span onclick="goVideo(this)" class="timestamp">35:54</span></p>
<p>So, what's the first, yeah question? <span onclick="goVideo(this)" class="timestamp">36:03</span></p>
<p>[student speaking off mic] So the question is, because that, because the gradient also depends on our loss, won't one backprop differently compared to the other? <span onclick="goVideo(this)" class="timestamp">36:06</span></p>
<p>So in the last layer, like yes, you do have basically some of this, the gradients will get the same, sorry, will get different loss for each specific neuron based on which class it was connected to, but if you look at all the neurons generally throughout your network, like you're going to, you basically have a lot of these neurons that are connected in exactly the same way. <span onclick="goVideo(this)" class="timestamp">36:30</span></p>
<p>They had the same updates and it's basically going to be the problem. <span onclick="goVideo(this)" class="timestamp">36:54</span></p>
<p>Okay, so the first idea that we can have to try and improve upon this is to set all of the weights to be small random numbers that we can sample from a distribution. <span onclick="goVideo(this)" class="timestamp">37:00</span></p>
<p>So, in this case, we're going to sample from basically a standard gaussian, but we're going to scale it so that the standard deviation is actually one E negative two, 0.01. <span onclick="goVideo(this)" class="timestamp">37:11</span></p>
<p>And so, just give this many small random weights. <span onclick="goVideo(this)" class="timestamp">37:23</span></p>
<p>And so, this does work okay for small networks, now we've broken the symmetry, but there's going to be problems with deeper networks. <span onclick="goVideo(this)" class="timestamp">37:26</span></p>
<p>And so, let's take a look at why this is the case. <span onclick="goVideo(this)" class="timestamp">37:36</span></p>
<p>So, here this is basically an experiment that we can do where let's take a deeper network. <span onclick="goVideo(this)" class="timestamp">37:39</span></p>
<p>So in this case, let's initialize a 10 layer neural network to have 500 neurons in each of these 10 layers. <span onclick="goVideo(this)" class="timestamp">37:45</span></p>
<p>Okay, we'll use tanh nonlinearities in this case and we'll initialize it with small random numbers as we described in the last slide. <span onclick="goVideo(this)" class="timestamp">37:54</span></p>
<p>So here, we're going to basically just initialize this network. <span onclick="goVideo(this)" class="timestamp">38:03</span></p>
<p>We have random data that we're going to take, and now let's just pass it through the entire network, and at each layer, look at the statistics of the activations that come out of that layer. <span onclick="goVideo(this)" class="timestamp">38:06</span></p>
<p>And so, what we'll see this is probably a little bit hard to read up top, but if we compute the mean and the standard deviations at each layer, well see that at the first layer this is, the means are always around zero. <span onclick="goVideo(this)" class="timestamp">38:23</span></p>
<p>There's a funny sound in here. <span onclick="goVideo(this)" class="timestamp">38:40</span></p>
<p>Interesting, okay well that was fixed. <span onclick="goVideo(this)" class="timestamp">38:45</span></p>
<p>So, if we look at, if we look at the outputs from here, the mean is always going to be around zero, which makes sense. <span onclick="goVideo(this)" class="timestamp">38:50</span></p>
<p>So, if we look here, let's see, if we take this, we looked at the dot product of X with W, and then we took the tanh on linearity, and then we store these values and so, because it tanh is centered around zero, this will make sense, and then the standard deviation however shrinks, and it quickly collapses to zero. <span onclick="goVideo(this)" class="timestamp">38:58</span></p>
<p>So, if we're plotting this, here this second row of plots here is showing the mean and standard deviations over time per layer and then in the bottom, the sequence of plots is showing for each of our layers. <span onclick="goVideo(this)" class="timestamp">39:23</span></p>
<p>What's the distribution of the activations that we have? <span onclick="goVideo(this)" class="timestamp">39:35</span></p>
<p>And so, we can see that at the first layer, we still have a reasonable gaussian looking thing. <span onclick="goVideo(this)" class="timestamp">39:39</span></p>
<p>It's a nice distribution. <span onclick="goVideo(this)" class="timestamp">39:43</span></p>
<p>But the problem is that as we multiply by this W, these small numbers at each layer, this quickly shrinks and collapses all of these values, as we multiply this over and over again. <span onclick="goVideo(this)" class="timestamp">39:45</span></p>
<p>And so, by the end, we get all of these zeros, which is not what we want. <span onclick="goVideo(this)" class="timestamp">39:59</span></p>
<p>So we get all the activations become zero. <span onclick="goVideo(this)" class="timestamp">40:04</span></p>
<p>And so now let's think about the backwards pass. <span onclick="goVideo(this)" class="timestamp">40:08</span></p>
<p>So, if we do a backward pass, now assuming this was our forward pass and now we want to compute our gradients. <span onclick="goVideo(this)" class="timestamp">40:11</span></p>
<p>So first, what does the gradients look like on the weights? <span onclick="goVideo(this)" class="timestamp">40:16</span></p>
<p>Does anyone have a guess? <span onclick="goVideo(this)" class="timestamp">40:24</span></p>
<p>So, if we think about this, we have our input values are very small at each layer right, because they've all collapsed at this near zero, and then now each layer, we have our upstream gradient flowing down, and then in order to get the gradient on the weights remember it's our upstream gradient times our local gradient, which for this this dot product were doing W times X. <span onclick="goVideo(this)" class="timestamp">40:29</span></p>
<p>It's just basically going to be X, which is our inputs. <span onclick="goVideo(this)" class="timestamp">40:54</span></p>
<p>So, it's again a similar kind of problem that we saw earlier, where now since, so here because X is small, our weights are getting a very small gradient, and they're basically not updating. <span onclick="goVideo(this)" class="timestamp">40:57</span></p>
<p>So, this is a way that you can basically try and think about the effect of gradient flows through your networks. <span onclick="goVideo(this)" class="timestamp">41:07</span></p>
<p>You can always think about what the forward pass is doing, and then think about what's happening as you have gradient flows coming down, and different types of inputs, what the effect of this actually is on our weights and the gradients on them. <span onclick="goVideo(this)" class="timestamp">41:14</span></p>
<p>And so also, if now if we think about what's the gradient that's going to be flowing back from each layer as we're chaining all these gradients. <span onclick="goVideo(this)" class="timestamp">41:29</span></p>
<p>Alright, so this is going to be the flip thing where we have now the gradient flowing back is our upstream gradient times in this case the local gradient is W on our input X. <span onclick="goVideo(this)" class="timestamp">41:40</span></p>
<p>And so again, because this is the dot product, and so now, actually going backwards at each layer, we're basically doing a multiplication of the upstream gradient by our weights in order to get the next gradient flowing downwards. <span onclick="goVideo(this)" class="timestamp">41:50</span></p>
<p>And so because here, we're multiplying by W over and over again. <span onclick="goVideo(this)" class="timestamp">42:07</span></p>
<p>You're getting basically the same phenomenon as we had in the forward pass where everything is getting smaller and smaller. <span onclick="goVideo(this)" class="timestamp">42:11</span></p>
<p>And now the gradient, upstream gradients are collapsing to zero as well. <span onclick="goVideo(this)" class="timestamp">42:18</span></p>
<p>Question? <span onclick="goVideo(this)" class="timestamp">42:24</span></p>
<p>[student speaking off mic] Yes, I guess upstream and downstream is, can be interpreted differently, depending on if you're going forward and backward, but in this case we're going, we're doing, we're going backwards, right? <span onclick="goVideo(this)" class="timestamp">42:25</span></p>
<p>We're doing back propagation. <span onclick="goVideo(this)" class="timestamp">42:43</span></p>
<p>And so upstream is the gradient flowing, you can think of a flow from your loss, all the way back to your input. <span onclick="goVideo(this)" class="timestamp">42:44</span></p>
<p>And so upstream is what came from what you've already done, flowing you know, down into your current node. <span onclick="goVideo(this)" class="timestamp">42:52</span></p>
<p>Right, so we're for flowing downwards, and what we get coming into the node through backprop is coming from upstream. <span onclick="goVideo(this)" class="timestamp">43:00</span></p>
<p>Okay, so now let's think about what happens when, you know we saw that this was a problem when our weights were pretty small, right? <span onclick="goVideo(this)" class="timestamp">43:14</span></p>
<p>So, we can think about well, what if we just try and solve this by making our weights big? <span onclick="goVideo(this)" class="timestamp">43:21</span></p>
<p>So, let's sample from this standard gaussian, now with standard deviation one instead of 0.01. <span onclick="goVideo(this)" class="timestamp">43:26</span></p>
<p>So what's the problem here? <span onclick="goVideo(this)" class="timestamp">43:35</span></p>
<p>Does anyone have a guess? <span onclick="goVideo(this)" class="timestamp">43:39</span></p>
<p>If our weights are now all big, and we're passing them, and we're taking these outputs of W times X, and passing them through tanh nonlinearities, remember we were talking about what happens at different values of inputs to tanh, so what's the problem? <span onclick="goVideo(this)" class="timestamp">43:45</span></p>
<p>Okay, so yeah I heard that it's going to be saturated, so that's right. <span onclick="goVideo(this)" class="timestamp">44:02</span></p>
<p>Basically now, because our weights are going to be big, we're going to always be at saturated regimes of either very negative or very positive of the tanh. <span onclick="goVideo(this)" class="timestamp">44:06</span></p>
<p>And so in practice, what you're going to get here is now if we look at the distribution of the activations at each of the layers here on the bottom, they're going to be all basically negative one or plus one. <span onclick="goVideo(this)" class="timestamp">44:16</span></p>
<p>Right, and so this will have the problem that we talked about with the tanh earlier, when they're saturated, that all the gradients will be zero, and our weights are not updating. <span onclick="goVideo(this)" class="timestamp">44:31</span></p>
<p>So basically, it's really hard to get your weight initialization right. <span onclick="goVideo(this)" class="timestamp">44:41</span></p>
<p>When it's too small they all collapse. <span onclick="goVideo(this)" class="timestamp">44:46</span></p>
<p>When it's too large they saturate. <span onclick="goVideo(this)" class="timestamp">44:48</span></p>
<p>So, there's been some work in trying to figure out well, what's the proper way to initialize these weights. <span onclick="goVideo(this)" class="timestamp">44:50</span></p>
<p>And so, one kind of good rule of thumb that you can use is the Xavier initialization. <span onclick="goVideo(this)" class="timestamp">44:56</span></p>
<p>And so this is from this paper by Glorot in 2010. <span onclick="goVideo(this)" class="timestamp">45:03</span></p>
<p>And so what this formula is, is if we look at W up here, we can see that we want to initialize them to these, we sample from our standard gaussian, and then we're going to scale by the number of inputs that we have. <span onclick="goVideo(this)" class="timestamp">45:07</span></p>
<p>And you can go through the math, and you can see in the lecture notes as well as in this paper of exactly how this works out, but basically the way we do it is we specify that we want the variance of the input to be the same as a variance of the output, and then if you derive what the weight should be you'll get this formula, and intuitively with this kind of means is that if you have a small number of inputs right, then we're going to divide by the smaller number and get larger weights, and we need larger weights, because with small inputs, and you're multiplying each of these by weight, you need a larger weights to get the same larger variance at output, and kind of vice versa for if we have many inputs, then we want smaller weights in order to get the same spread at the output. <span onclick="goVideo(this)" class="timestamp">45:23</span></p>
<p>So, you can look at the notes for more details about this. <span onclick="goVideo(this)" class="timestamp">46:09</span></p>
<p>And so basically now, if we want to have a unit gaussian, right as input to each layer, we can use this kind of initialization to at training time, to be able to initialize this, so that there is approximately a unit gaussian at each layer. <span onclick="goVideo(this)" class="timestamp">46:11</span></p>
<p>Okay, and so one thing is does assume though is that it is assumed that there's linear activations. <span onclick="goVideo(this)" class="timestamp">46:29</span></p>
<p>and so it assumes that we are in the activation, in the active region of the tanh, for example. <span onclick="goVideo(this)" class="timestamp">46:35</span></p>
<p>And so again, you can look at the notes to really try and understand its derivation, but the problem is that this breaks when now you use something like a ReLU. <span onclick="goVideo(this)" class="timestamp">46:41</span></p>
<p>Right, and so with the ReLU what happens is that, because it's killing half of your units, it's setting approximately half of them to zero at each time, it's actually halving the variance that you get out of this. <span onclick="goVideo(this)" class="timestamp">46:51</span></p>
<p>And so now, if you just make the same assumptions as your derivation earlier you won't actually get the right variance coming out, it's going to be too small. <span onclick="goVideo(this)" class="timestamp">47:05</span></p>
<p>And so what you see is again this kind of phenomenon, as the distributions starts collapsing. <span onclick="goVideo(this)" class="timestamp">47:16</span></p>
<p>In this case you get more and more peaked toward zero, and more units deactivated. <span onclick="goVideo(this)" class="timestamp">47:23</span></p>
<p>And the way to address this with something that has been pointed out in some papers, which is that you can you can try to account for this with an extra, divided by two. <span onclick="goVideo(this)" class="timestamp">47:30</span></p>
<p>So, now you're basically adjusting for the fact that half the neurons get killed. <span onclick="goVideo(this)" class="timestamp">47:42</span></p>
<p>And so you're kind of equivalent input has actually half this number of input, and so you just add this divided by two factor in, this works much better, and you can see that the distributions are pretty good throughout all layers of the network. <span onclick="goVideo(this)" class="timestamp">47:49</span></p>
<p>And so in practice this is been really important actually, for training these types of little things, to a really pay attention to how your weights are, make a big difference. <span onclick="goVideo(this)" class="timestamp">48:07</span></p>
<p>And so for example, you'll see in some papers that this actually is the difference between the network even training at all and performing well versus nothing happening. <span onclick="goVideo(this)" class="timestamp">48:16</span></p>
<p>So, proper initialization is still an active area of research. <span onclick="goVideo(this)" class="timestamp">48:33</span></p>
<p>And so if you're interested in this, you can look at a lot of these papers and resources. <span onclick="goVideo(this)" class="timestamp">48:36</span></p>
<p>A good general rule of thumb is basically use the Xavier Initialization to start with, and then you can also think about some of these other kinds of methods. <span onclick="goVideo(this)" class="timestamp">48:40</span></p>
<p>And so now we're going to talk about a related idea to this, so this idea of wanting to keep activations in a gaussian range that we want. <span onclick="goVideo(this)" class="timestamp">48:54</span></p>
<p>Right, and so this idea behind what we're going to call batch normalization is, okay we want unit gaussian activations. <span onclick="goVideo(this)" class="timestamp">49:03</span></p>
<p>Let's just make them that way. <span onclick="goVideo(this)" class="timestamp">49:10</span></p>
<p>Let's just force them to be that way. <span onclick="goVideo(this)" class="timestamp">49:11</span></p>
<p>And so how does this work? <span onclick="goVideo(this)" class="timestamp">49:14</span></p>
<p>So, let's consider a batch of activations at some layer. <span onclick="goVideo(this)" class="timestamp">49:16</span></p>
<p>And so now we have all of our activations coming out. <span onclick="goVideo(this)" class="timestamp">49:19</span></p>
<p>If we want to make this unit gaussian, we actually can just do this empirically, right. <span onclick="goVideo(this)" class="timestamp">49:23</span></p>
<p>We can take the mean of the batch that we have so far of the current batch, and we can just and the variance, and we can just normalize by this. <span onclick="goVideo(this)" class="timestamp">49:29</span></p>
<p>Right, and so basically, instead of with weight initialization, we're setting this at the start of training so that we try and get it into a good spot that we can have unit gaussians at every layer, and hopefully during training this will preserve this. <span onclick="goVideo(this)" class="timestamp">49:39</span></p>
<p>Now we're going to explicitly make that happen on every forward pass through the network. <span onclick="goVideo(this)" class="timestamp">49:53</span></p>
<p>We're going to make this happen functionally, and basically by normalizing by the mean and the variance of each neuron, we look at all of the inputs coming into it and calculate the mean and variance for that batch and normalize it by it. <span onclick="goVideo(this)" class="timestamp">49:58</span></p>
<p>And the thing is that this is a, this is just a differentiable function right? <span onclick="goVideo(this)" class="timestamp">50:16</span></p>
<p>If we have our mean and our variance as constants, this is just a sequence of computational operations that we can differentiate and do back prop through this. <span onclick="goVideo(this)" class="timestamp">50:20</span></p>
<p>Okay, so just as I was saying earlier right, if we look at our input data, and we think of this as we have N training examples in our current batch, and then each batch has dimension D, we're going to the compute the empirical mean and variance independently for each dimension, so each basically feature element, and we compute this across our batch, our current mini-batch that we have and we normalize by this. <span onclick="goVideo(this)" class="timestamp">50:33</span></p>
<p>And so this is usually inserted after fully connected or convolutional layers. <span onclick="goVideo(this)" class="timestamp">51:06</span></p>
<p>We saw that would we were multiplying by W in these layers, which we do over and over again, then we can have this bad scaling effect with each one. <span onclick="goVideo(this)" class="timestamp">51:10</span></p>
<p>And so this basically is able to undo this effect. <span onclick="goVideo(this)" class="timestamp">51:19</span></p>
<p>Right, and since we're basically just scaling by the inputs connected to each neuron, each activation, we can apply this the same way to fully connected convolutional layers, and the only difference is that, with convolutional layers, we want to normalize not just across all the training examples, and independently for each each feature dimension, but we actually want to normalize jointly across both all the feature dimensions, all the spatial locations that we have in our activation map, as well as all of the training examples. <span onclick="goVideo(this)" class="timestamp">51:23</span></p>
<p>And we do this, because we want to obey the convolutional property, and we want nearby locations to be normalized the same way, right? <span onclick="goVideo(this)" class="timestamp">51:59</span></p>
<p>And so with a convolutional layer, we're basically going to have a one mean and one standard deviation, per activation map that that we have, and we're going to normalize by this across all of the examples in the batch. <span onclick="goVideo(this)" class="timestamp">52:06</span></p>
<p>And so this is something that you guys are going to implement in your next homework. <span onclick="goVideo(this)" class="timestamp">52:18</span></p>
<p>And so, all of these details are explained very clearly in this paper from 2015. <span onclick="goVideo(this)" class="timestamp">52:23</span></p>
<p>And so on this is a very useful, useful technique that you want to use a lot in practice. <span onclick="goVideo(this)" class="timestamp">52:29</span></p>
<p>You want to have these batch normalization layers. <span onclick="goVideo(this)" class="timestamp">52:36</span></p>
<p>And so you should read this paper. <span onclick="goVideo(this)" class="timestamp">52:38</span></p>
<p>Go through all of the derivations, and then also go through the derivations of how to compute the gradients with given these, this normalization operation. <span onclick="goVideo(this)" class="timestamp">52:41</span></p>
<p>Okay, so one thing that I just want to point out is that, it's not clear that, you know, we're doing this batch normalization after every fully connected layer, and it's not clear that we necessarily want a unit gaussian input to these tanh nonlinearities, because what this is doing is this is constraining you to the linear regime of this nonlinearity, and we're not actually, you're trying to basically say, let's not have any of this saturation, but maybe a little bit of this is good, right? <span onclick="goVideo(this)" class="timestamp">52:57</span></p>
<p>You you want to be able to control what's, how much saturation that you want to have. <span onclick="goVideo(this)" class="timestamp">53:25</span></p>
<p>And so what, the way that we address this when we're doing batch normalization is that we have our normalization operation, but then after that we have this additional squashing and scaling operation. <span onclick="goVideo(this)" class="timestamp">53:32</span></p>
<p>So, we do our normalization. <span onclick="goVideo(this)" class="timestamp">53:45</span></p>
<p>Then we're going to scale by some constant gamma, and then shift by another factor of beta. <span onclick="goVideo(this)" class="timestamp">53:46</span></p>
<p>Right, and so what this actually does is that this allows you to be able to recover the identity function if you wanted to. <span onclick="goVideo(this)" class="timestamp">53:53</span></p>
<p>So, if the network wanted to, it could learn your scaling factor gamma to be just your variance. <span onclick="goVideo(this)" class="timestamp">54:02</span></p>
<p>It could learn your beta to be your mean, and in this case you can recover the identity mapping, as if you didn't have batch normalization. <span onclick="goVideo(this)" class="timestamp">54:08</span></p>
<p>And so now you have the flexibility of doing kind of everything in between and making your the network learning how to make your tanh more or less saturated, and how much to do so in order to have, to have good training. <span onclick="goVideo(this)" class="timestamp">54:17</span></p>
<p>Okay, so just to sort of summarize the batch normalization idea. <span onclick="goVideo(this)" class="timestamp">54:38</span></p>
<p>Right, so given our inputs, we're going to compute our mini-batch mean. <span onclick="goVideo(this)" class="timestamp">54:42</span></p>
<p>So, we do this for every mini-batch that's coming in. <span onclick="goVideo(this)" class="timestamp">54:49</span></p>
<p>We compute our variance. <span onclick="goVideo(this)" class="timestamp">54:51</span></p>
<p>We normalize by the mean and variance, and we have this additional scaling and shifting factor. <span onclick="goVideo(this)" class="timestamp">54:53</span></p>
<p>And so this improves gradient flow through the network. <span onclick="goVideo(this)" class="timestamp">54:58</span></p>
<p>it's also more robust as a result. <span onclick="goVideo(this)" class="timestamp">55:03</span></p>
<p>It works for more range of learning rates, and different kinds of initialization, so people have seen that once you put batch normalization in, and it's just easier to train, and so that's why you should do this. <span onclick="goVideo(this)" class="timestamp">55:06</span></p>
<p>And then also when one thing that I just want to point out is that you can also think of this as in a way also doing some regularization. <span onclick="goVideo(this)" class="timestamp">55:17</span></p>
<p>Right and so, because now at the output of each layer, each of these activations, each of these outputs, is an output of both your input X, as well as the other examples in the batch that it happens to be sampled with, right, because you're going to normalize each input data by the empirical mean over that batch. <span onclick="goVideo(this)" class="timestamp">55:27</span></p>
<p>So because of that, it's no longer producing deterministic values for a given training example, and it's tying all of these inputs in a batch together. <span onclick="goVideo(this)" class="timestamp">55:48</span></p>
<p>And so this basically, because it's no longer deterministic, kind of jitters your representation of X a little bit, and in a sense, gives some sort of regularization effect. <span onclick="goVideo(this)" class="timestamp">55:58</span></p>
<p>Yeah, question? <span onclick="goVideo(this)" class="timestamp">56:09</span></p>
<p>[student speaking off camera] The question is gamma and beta are learned parameters, and yes that's the case. <span onclick="goVideo(this)" class="timestamp">56:11</span></p>
<p>[student speaking off mic] Yeah, so the question is why do we want to learn this gamma and beta to be able to learn the identity function back, and the reason is because you want to give it the flexibility. <span onclick="goVideo(this)" class="timestamp">56:17</span></p>
<p>Right, so what batch normalization is doing, is it's forcing our data to become this unit gaussian, our inputs to be unit gaussian, but even though in general this is a good idea, it's not always that this is exactly the best thing to do. <span onclick="goVideo(this)" class="timestamp">56:39</span></p>
<p>And we saw in particular for something like a tanh, you might want to control some degree of saturation that you have. <span onclick="goVideo(this)" class="timestamp">56:54</span></p>
<p>And so what this does is it gives you the flexibility of doing this exact like unit gaussian normalization, if it wants to, but also learning that maybe in this particular part of the network, maybe that's not the best thing to do. <span onclick="goVideo(this)" class="timestamp">57:00</span></p>
<p>Maybe we want something still in this general idea, but slightly different right, slightly scaled or shifted. <span onclick="goVideo(this)" class="timestamp">57:14</span></p>
<p>And so these parameters just give it that extra flexibility to learn that if it wants to. <span onclick="goVideo(this)" class="timestamp">57:20</span></p>
<p>And then yeah, if the the best thing to do is just batch normalization then it'll learn the right parameters for that. <span onclick="goVideo(this)" class="timestamp">57:26</span></p>
<p>Yeah? <span onclick="goVideo(this)" class="timestamp">57:35</span></p>
<p>[student speaking off mic] Yeah, so basically each neuron output. <span onclick="goVideo(this)" class="timestamp">57:36</span></p>
<p>So, we have output of a fully connected layer. <span onclick="goVideo(this)" class="timestamp">57:44</span></p>
<p>We have W times X. <span onclick="goVideo(this)" class="timestamp">57:47</span></p>
<p>and so we have the values of each of these outputs, and then we're going to apply batch normalization separately to each of these neurons. <span onclick="goVideo(this)" class="timestamp">57:48</span></p>
<p>Question? <span onclick="goVideo(this)" class="timestamp">57:57</span></p>
<p>[student speaking off mic] Yeah, so the question is that for things like reinforcement learning, you might have a really small batch size. <span onclick="goVideo(this)" class="timestamp">57:59</span></p>
<p>How do you deal with this? <span onclick="goVideo(this)" class="timestamp">58:15</span></p>
<p>So in practice, I guess batch normalization has been used a lot for like for standard convolutional neural networks, and there's actually papers on how do we want to do normalization for different kinds of recurrent networks, or you know some of these networks that might also be in reinforcement learning. <span onclick="goVideo(this)" class="timestamp">58:18</span></p>
<p>And so there's different considerations that you might want to think of there. <span onclick="goVideo(this)" class="timestamp">58:35</span></p>
<p>And this is still an active area of research. <span onclick="goVideo(this)" class="timestamp">58:38</span></p>
<p>There's papers on this and we might also talk about some of this more later, but for a typical convolutional neural network this generally works fine. <span onclick="goVideo(this)" class="timestamp">58:41</span></p>
<p>And then if you have a smaller batch size, maybe this becomes a little bit less accurate, but you still get kind of the same effect. <span onclick="goVideo(this)" class="timestamp">58:50</span></p>
<p>And you know it's possible also that you could design your mean and variance to be computed maybe over more examples, right, and I think in practice usually it's just okay, so you don't see this too much, but this is something that maybe could help if that was a problem. <span onclick="goVideo(this)" class="timestamp">58:58</span></p>
<p>Yeah, question? <span onclick="goVideo(this)" class="timestamp">59:15</span></p>
<p>[student speaking off mic] So the question, so the question is, if we force the inputs to be gaussian, do we lose the structure? <span onclick="goVideo(this)" class="timestamp">59:16</span></p>
<p>So, no in a sense that you can think of like, if you had all your features distributed as a gaussian for example, even if you were just doing data pre-processing, this gaussian is not losing you any structure. <span onclick="goVideo(this)" class="timestamp">59:35</span></p>
<p>All the, it's just shifting and scaling your data into a regime, that works well for the operations that you're going to perform on it. <span onclick="goVideo(this)" class="timestamp">59:48</span></p>
<p>In convolutional layers, you do have some structure, that you want to preserve spatially, right. <span onclick="goVideo(this)" class="timestamp">59:58</span></p>
<p>You want, like if you look at your activation maps, you want them to relatively all make sense to each other. <span onclick="goVideo(this)" class="timestamp">60:03</span></p>
<p>So, in this case you do want to take that into consideration. <span onclick="goVideo(this)" class="timestamp">60:09</span></p>
<p>And so now, we're going to normalize, find one mean for the entire activation map, so we only find the empirical mean and variance over training examples. <span onclick="goVideo(this)" class="timestamp">60:13</span></p>
<p>And so that's something that you'll be doing in your homework, and also explained in the paper as well. <span onclick="goVideo(this)" class="timestamp">60:23</span></p>
<p>So, you should refer to that. <span onclick="goVideo(this)" class="timestamp">60:31</span></p>
<p>Yes. <span onclick="goVideo(this)" class="timestamp">60:33</span></p>
<p>[student speaking off mic] So the question is, are we normalizing the weight so that they become gaussian. <span onclick="goVideo(this)" class="timestamp">60:34</span></p>
<p>So, if I understand your question correctly, then the answer is, we're normalizing the inputs to each layer, so we're not changing the weights in this process. <span onclick="goVideo(this)" class="timestamp">60:48</span></p>
<p>[student speaking off mic] Yeah, so the question is, once we subtract by the mean and divide by the standard deviation, does this become gaussian, and the answer is yes. <span onclick="goVideo(this)" class="timestamp">61:01</span></p>
<p>So, if you think about the operations that are happening, basically you're shifting by the mean, right. <span onclick="goVideo(this)" class="timestamp">61:25</span></p>
<p>And so this shift up to be zero-centered, and then you're scaling by the standard deviation. <span onclick="goVideo(this)" class="timestamp">61:31</span></p>
<p>This now transforms this into a unit gaussian. <span onclick="goVideo(this)" class="timestamp">61:37</span></p>
<p>And so if you want to look more into that, I think you can look at, there's a lot of machine learning explanations that go into exactly what this, visualizing with this operation is doing, but yeah this basically takes your data and turns it into a gaussian distribution. <span onclick="goVideo(this)" class="timestamp">61:41</span></p>
<p>Okay, so yeah question? <span onclick="goVideo(this)" class="timestamp">62:01</span></p>
<p>[student speaking off mic] Uh-huh. <span onclick="goVideo(this)" class="timestamp">62:04</span></p>
<p>So the question is, if we're going to be doing the shift and scale, and learning these is the batch normalization redundant, because you could recover the identity mapping? <span onclick="goVideo(this)" class="timestamp">62:26</span></p>
<p>So in the case that the network learns that identity mapping is always the best, and it learns these parameters, the yeah, there would be no point for batch normalization, but in practice this doesn't happen. <span onclick="goVideo(this)" class="timestamp">62:36</span></p>
<p>So in practice, we will learn this gamma and beta. <span onclick="goVideo(this)" class="timestamp">62:46</span></p>
<p>That's not the same as a identity mapping. <span onclick="goVideo(this)" class="timestamp">62:50</span></p>
<p>So, it will shift and scale by some amount, but not the amount that's going to give you an identity mapping. <span onclick="goVideo(this)" class="timestamp">62:53</span></p>
<p>And so what you get is you still get this batch normalization effect. <span onclick="goVideo(this)" class="timestamp">62:59</span></p>
<p>Right, so having this identity mapping there, I'm only putting this here to say that in the extreme, it could learn the identity mapping, but in practice it doesn't. <span onclick="goVideo(this)" class="timestamp">63:03</span></p>
<p>Yeah, question. <span onclick="goVideo(this)" class="timestamp">63:14</span></p>
<p>[student speaking off mic] Yeah. <span onclick="goVideo(this)" class="timestamp">63:16</span></p>
<p>[student speaking off mic] Oh, right, right. <span onclick="goVideo(this)" class="timestamp">63:23</span></p>
<p>Yeah, yeah sorry, I was not clear about this, but yeah I think this is related to the other question earlier, that yeah when we're doing this we're actually getting zero mean and unit gaussian, which put this into a nice shape, but it doesn't have to actually be a gaussian. <span onclick="goVideo(this)" class="timestamp">63:34</span></p>
<p>So yeah, I mean ideally, if we're looking at like inputs coming in, as you know, sort of approximately gaussian, we would like it to have this kind of effect, but yeah, in practice it doesn't have to be. <span onclick="goVideo(this)" class="timestamp">63:50</span></p>
<p>Okay, so ... <span onclick="goVideo(this)" class="timestamp">64:07</span></p>
<p>Okay, so the last thing I just want to mention about this is that, so at test time, the batch normalization layer, we now take the empirical mean and variance from the training data. <span onclick="goVideo(this)" class="timestamp">64:10</span></p>
<p>So, we don't re-compute this at test time. <span onclick="goVideo(this)" class="timestamp">64:25</span></p>
<p>We just estimate this at training time, for example using running averages, and then we're going to use this as at test time. <span onclick="goVideo(this)" class="timestamp">64:27</span></p>
<p>So, we're just going to scale by that. <span onclick="goVideo(this)" class="timestamp">64:35</span></p>
<p>Okay, so now I'm going to move on to babysitting the learning process. <span onclick="goVideo(this)" class="timestamp">64:40</span></p>
<p>Right, so now we've defined our network architecture, and we'll talk about how do we monitor training, and how do we adjust hyperparameters as we go, to get good learning results? <span onclick="goVideo(this)" class="timestamp">64:44</span></p>
<p>So as always, so the first step we want to do, is we want to pre-process the data. <span onclick="goVideo(this)" class="timestamp">64:58</span></p>
<p>Right, so we want to zero mean the data as we talked about earlier. <span onclick="goVideo(this)" class="timestamp">65:02</span></p>
<p>Then we want to choose the architecture, and so here we are starting with one hidden layer of 50 neurons, for example, but we've basically we can pick any architecture that we want to start with. <span onclick="goVideo(this)" class="timestamp">65:06</span></p>
<p>And then the first thing that we want to do is we initialize our network. <span onclick="goVideo(this)" class="timestamp">65:20</span></p>
<p>We do a forward pass through it, and we want to make sure that our loss is reasonable. <span onclick="goVideo(this)" class="timestamp">65:24</span></p>
<p>So, we talked about this several lectures ago, where we have a basically a, let's say we have a Softmax classifier that we have here. <span onclick="goVideo(this)" class="timestamp">65:29</span></p>
<p>We know what our loss should be, when our weights are small, and we have generally a diffuse distribution. <span onclick="goVideo(this)" class="timestamp">65:38</span></p>
<p>Then we want it to be, the Softmax classifier loss is going to be your negative log likelihood, which if we have 10 classes, it'll be something like negative log of one over 10, which here is around 2.3, and so we want to make sure that our loss is what we expect it to be. <span onclick="goVideo(this)" class="timestamp">65:44</span></p>
<p>So, this is a good sanity check that we want to always, always do. <span onclick="goVideo(this)" class="timestamp">66:03</span></p>
<p>So, now once we've seen that our original loss is good, now we want to, so first we want to do this having zero regularization, right. <span onclick="goVideo(this)" class="timestamp">66:10</span></p>
<p>So, when we disable the regularization, now our only loss term is this data loss, which is going to give 2.3 here. <span onclick="goVideo(this)" class="timestamp">66:18</span></p>
<p>And so here, now we want to crank up the regularization, and when we do that, we want to see that our loss goes up, because we've added this additional regularization term. <span onclick="goVideo(this)" class="timestamp">66:26</span></p>
<p>So, this is a good next step that you can do for your sanity check. <span onclick="goVideo(this)" class="timestamp">66:36</span></p>
<p>And then, now we can start training. <span onclick="goVideo(this)" class="timestamp">66:41</span></p>
<p>So, now we start trying to train. <span onclick="goVideo(this)" class="timestamp">66:44</span></p>
<p>What we do is, a good way to do this is to start up with a very small amount of data, because if you have just a very small training set, you should be able to over fit this very well and get very good training loss on here. <span onclick="goVideo(this)" class="timestamp">66:47</span></p>
<p>And so in this case we want to turn off our regularization again, and just see if we can make the loss go down to zero. <span onclick="goVideo(this)" class="timestamp">67:01</span></p>
<p>And so we can see how our loss is changing, as we have all these epochs. <span onclick="goVideo(this)" class="timestamp">67:12</span></p>
<p>We compute our loss at each epoch, and we want to see this go all the way down to zero. <span onclick="goVideo(this)" class="timestamp">67:16</span></p>
<p>Right, and here we can see that also our training accuracy is going all the way up to one, and this makes sense right. <span onclick="goVideo(this)" class="timestamp">67:22</span></p>
<p>If you have a very small number of data, you should be able to over fit this perfectly. <span onclick="goVideo(this)" class="timestamp">67:27</span></p>
<p>Okay, so now once you've done that, these are all sanity checks. <span onclick="goVideo(this)" class="timestamp">67:35</span></p>
<p>Now you can start really trying to train. <span onclick="goVideo(this)" class="timestamp">67:39</span></p>
<p>So, now you can take your full training data, and now start with a small amount of regularization, and let's first figure out what's a good learning rate. <span onclick="goVideo(this)" class="timestamp">67:40</span></p>
<p>So, learning rate is one of the most important hyperparameters, and it's something that you want to adjust first. <span onclick="goVideo(this)" class="timestamp">67:50</span></p>
<p>So, you want to try some value of learning rate. <span onclick="goVideo(this)" class="timestamp">67:55</span></p>
<p>and here I've tried one E negative six, and you can see that the loss is barely changing. <span onclick="goVideo(this)" class="timestamp">67:58</span></p>
<p>Right, and so the reason this is barely changing is usually because your learning rate is too small. <span onclick="goVideo(this)" class="timestamp">68:04</span></p>
<p>So when it's too small, your gradient updates are not big enough, and your cost is basically about the same. <span onclick="goVideo(this)" class="timestamp">68:10</span></p>
<p>Okay, so, one thing that I want to point out here, is that we can notice that even though our loss with barely changing, the training and the validation accuracy jumped up to 20% very quickly. <span onclick="goVideo(this)" class="timestamp">68:18</span></p>
<p>And so does anyone have any idea for why this might be the case? <span onclick="goVideo(this)" class="timestamp">68:33</span></p>
<p>Why, so remember we have a Softmax function, and our loss didn't really change, but our accuracy improved a lot. <span onclick="goVideo(this)" class="timestamp">68:40</span></p>
<p>Okay, so the reason for this is that here the probabilities are still pretty diffuse, so our loss term is still pretty similar, but when we shift all of these probabilities slightly in the right direction, because we're learning right? <span onclick="goVideo(this)" class="timestamp">68:50</span></p>
<p>Our weights are changing the right direction. <span onclick="goVideo(this)" class="timestamp">69:06</span></p>
<p>Now the accuracy all of a sudden can jump, because we're taking the maximum correct value, and so we're going to get a big jump in accuracy, even though our loss is still relatively diffuse. <span onclick="goVideo(this)" class="timestamp">69:08</span></p>
<p>Okay, so now if we try another learning rate, now here I'm jumping in the other extreme, picking a very big learning rate, one E negative six. <span onclick="goVideo(this)" class="timestamp">69:24</span></p>
<p>What's happening is that our cost is now giving us NaNs. <span onclick="goVideo(this)" class="timestamp">69:31</span></p>
<p>And, when you have NaNs, what this usually means is that basically your cost exploded. <span onclick="goVideo(this)" class="timestamp">69:36</span></p>
<p>And so, the reason for that is typically that your learning rate was too high. <span onclick="goVideo(this)" class="timestamp">69:42</span></p>
<p>So, then you can adjust your learning rate down again. <span onclick="goVideo(this)" class="timestamp">69:49</span></p>
<p>Here I can see that we're trying three E to the negative three. <span onclick="goVideo(this)" class="timestamp">69:51</span></p>
<p>The cost is still exploding. <span onclick="goVideo(this)" class="timestamp">69:55</span></p>
<p>So, usually this, the rough range for learning rates that we want to look at is between one E negative three, and one E negative five. <span onclick="goVideo(this)" class="timestamp">69:57</span></p>
<p>And, this is the rough range that we want to be cross-validating in between. <span onclick="goVideo(this)" class="timestamp">70:05</span></p>
<p>So, you want to try out values in this range, and depending on whether your loss is too slow, or too small, or whether it's too large, adjust it based on this. <span onclick="goVideo(this)" class="timestamp">70:10</span></p>
<p>And so how do we exactly pick these hyperparameters? <span onclick="goVideo(this)" class="timestamp">70:21</span></p>
<p>Do hyperparameter optimization, and pick the best values of all of these hyperparameters? <span onclick="goVideo(this)" class="timestamp">70:24</span></p>
<p>So, the strategy that we're going to use is for any hyperparameter for example learning rate, is to do cross-validation. <span onclick="goVideo(this)" class="timestamp">70:31</span></p>
<p>So, cross-validation is training on your training set, and then evaluating on a validation set. <span onclick="goVideo(this)" class="timestamp">70:38</span></p>
<p>How well do this hyperparameter do? <span onclick="goVideo(this)" class="timestamp">70:44</span></p>
<p>Something that you guys have already done in your assignment. <span onclick="goVideo(this)" class="timestamp">70:46</span></p>
<p>And so typically we want to do this in stages. <span onclick="goVideo(this)" class="timestamp">70:49</span></p>
<p>And so, we can do first of course stage, where we pick values pretty spread out apart, and then we learn for only a few epochs. <span onclick="goVideo(this)" class="timestamp">70:51</span></p>
<p>And with only a few epochs. <span onclick="goVideo(this)" class="timestamp">71:00</span></p>
<p>you can already get a pretty good sense of which hyperparameters, which values are good or not, right. <span onclick="goVideo(this)" class="timestamp">71:02</span></p>
<p>You can quickly see that it's a NaN, or you can see that nothing is happening, and you can adjust accordingly. <span onclick="goVideo(this)" class="timestamp">71:08</span></p>
<p>So, typically once you do that, then you can see what's sort of a pretty good range, and the range that you want to now do finer sampling of values in. <span onclick="goVideo(this)" class="timestamp">71:14</span></p>
<p>And so, this is the second stage, where now you might want to run this for a longer time, and do a finer search over that region. <span onclick="goVideo(this)" class="timestamp">71:23</span></p>
<p>And one tip for detecting explosions like NaNs, you can have in your training loop, right sample some hyperparameter, start training, and then look at your cost at every iteration or every epoch. <span onclick="goVideo(this)" class="timestamp">71:31</span></p>
<p>And if you ever get a cost that's much larger than your original cost, so for example, something like three times original cost, then you know that this is not heading in the right direction. <span onclick="goVideo(this)" class="timestamp">71:47</span></p>
<p>Right, it's getting very big, very quickly, and you can just break out of your loop, stop this this hyperparameter choice and pick something else. <span onclick="goVideo(this)" class="timestamp">71:58</span></p>
<p>Alright, so an example of this, let's say here we want to run now course search for five epochs. <span onclick="goVideo(this)" class="timestamp">72:06</span></p>
<p>This is a similar network that we were talking about earlier, and what we can do is we can see all of these validation accuracy that we're getting. <span onclick="goVideo(this)" class="timestamp">72:14</span></p>
<p>And I've put in, highlighted in red the ones that gives better values. <span onclick="goVideo(this)" class="timestamp">72:25</span></p>
<p>And so these are going to be regions that we're going to look into in more detail. <span onclick="goVideo(this)" class="timestamp">72:29</span></p>
<p>And one thing to note is that it's usually better to optimize in log space. <span onclick="goVideo(this)" class="timestamp">72:33</span></p>
<p>And so here instead of sampling, I'd say uniformly between you know one E to the negative 0.01 and 100, you're going to actually do 10 to the power of some range. <span onclick="goVideo(this)" class="timestamp">72:37</span></p>
<p>Right, and this is because the learning rate is multiplying your gradient update. <span onclick="goVideo(this)" class="timestamp">72:50</span></p>
<p>And so it has these multiplicative effects, and so it makes more sense to consider a range of learning rates that are multiplied or divided by some value, rather than uniformly sampled. <span onclick="goVideo(this)" class="timestamp">72:56</span></p>
<p>So, you want to be dealing with orders of some magnitude here. <span onclick="goVideo(this)" class="timestamp">73:08</span></p>
<p>Okay, so once you find that, you can then adjust your range. <span onclick="goVideo(this)" class="timestamp">73:11</span></p>
<p>Right get in this case, we have a range of you know, maybe of 10 to the negative four, right, to 10 to the zero power. <span onclick="goVideo(this)" class="timestamp">73:14</span></p>
<p>This is a good range that we want to narrow down into. <span onclick="goVideo(this)" class="timestamp">73:23</span></p>
<p>And so we can do this again, and here we can see that we're getting a relatively good accuracy of 53%. <span onclick="goVideo(this)" class="timestamp">73:26</span></p>
<p>And so this means we're headed in the right direction. <span onclick="goVideo(this)" class="timestamp">73:33</span></p>
<p>The one thing that I want to point out is that here we actually have a problem. <span onclick="goVideo(this)" class="timestamp">73:38</span></p>
<p>And so the problem is that we can see that our best accuracy here has a learning rate that's about, you know, all of our good learning rates are in this E to the negative four range. <span onclick="goVideo(this)" class="timestamp">73:42</span></p>
<p>Right, and since the learning rate that we specified was going from 10 to the negative four to 10 to the zero, that means that all the good learning rates, were at the edge of the range that we were sampling. <span onclick="goVideo(this)" class="timestamp">73:58</span></p>
<p>And so this is bad, because this means that we might not have explored our space sufficiently, right. <span onclick="goVideo(this)" class="timestamp">74:10</span></p>
<p>We might actually want to go to 10 to the negative five, or 10 to the negative six. <span onclick="goVideo(this)" class="timestamp">74:17</span></p>
<p>There might be still better ranges if we continue shifting down. <span onclick="goVideo(this)" class="timestamp">74:21</span></p>
<p>So, you want to make sure that your range kind of has the good values somewhere in the middle, or somewhere where you get a sense that you've hit, you've explored your range fully. <span onclick="goVideo(this)" class="timestamp">74:24</span></p>
<p>Okay, and so another thing is that we can sample all of our different hyperparameters, using a kind of grid search, right. <span onclick="goVideo(this)" class="timestamp">74:36</span></p>
<p>We can sample for a fixed set of combinations, a fixed set of values for each hyperparameter. <span onclick="goVideo(this)" class="timestamp">74:44</span></p>
<p>Sample in a grid manner over all of these values, but in practice it's actually better to sample from a random layout, so sampling random value of each hyperparameter in a range. <span onclick="goVideo(this)" class="timestamp">74:50</span></p>
<p>And so what you'll get instead is we'll have these two hyper parameters here that we want to sample from. <span onclick="goVideo(this)" class="timestamp">75:02</span></p>
<p>You'll get samples that look like this right side instead. <span onclick="goVideo(this)" class="timestamp">75:07</span></p>
<p>And the reason for this is that if a function is really sort of more of a function of one variable than another, which is usually true. <span onclick="goVideo(this)" class="timestamp">75:11</span></p>
<p>Usually we have little bit more, a lower effective dimensionality than we actually have. <span onclick="goVideo(this)" class="timestamp">75:20</span></p>
<p>Then you're going to get many more samples of the important variable that you have. <span onclick="goVideo(this)" class="timestamp">75:25</span></p>
<p>You're going to be able to see this shape in this green function that I've drawn on top, showing where the good values are, compared to if you just did a grid layout where we were only able to sample three values here, and you've missed where were the good regions. <span onclick="goVideo(this)" class="timestamp">75:30</span></p>
<p>Right, and so basically we'll get much more useful signal overall since we have more samples of different values of the important variable. <span onclick="goVideo(this)" class="timestamp">75:47</span></p>
<p>And so, hyperparameters to play with, we've talked about learning rate, things like different types of decay schedules, update types, regularization, also your network architecture, so the number of hidden units, the depth, all of these are hyperparameters that you can optimize over. <span onclick="goVideo(this)" class="timestamp">75:56</span></p>
<p>And we've talked about some of these, but we'll keep talking about more of these in the next lecture. <span onclick="goVideo(this)" class="timestamp">76:13</span></p>
<p>And so you can think of this as kind of, you know, if you're basically tuning all the knobs right, of some turntable where you're, you're a neural networks practitioner. <span onclick="goVideo(this)" class="timestamp">76:17</span></p>
<p>You can think of the music that's output is the loss function that you want, and you want to adjust everything appropriately to get the kind of output that you want. <span onclick="goVideo(this)" class="timestamp">76:28</span></p>
<p>Alright, so it's really kind of an art that you're doing. <span onclick="goVideo(this)" class="timestamp">76:36</span></p>
<p>And in practice, you're going to do a lot of hyperparameter optimization, a lot of cross validation. <span onclick="goVideo(this)" class="timestamp">76:42</span></p>
<p>And so you know, in order to get numbers, people will run cross validation over tons of hyperparameters, monitor all of them, see which ones are doing better, which ones are doing worse. <span onclick="goVideo(this)" class="timestamp">76:50</span></p>
<p>Here we have all these loss curves. <span onclick="goVideo(this)" class="timestamp">77:00</span></p>
<p>Pick the right ones, readjust, and keep going through this process. <span onclick="goVideo(this)" class="timestamp">77:02</span></p>
<p>And so as I mentioned earlier, as you're monitoring each of these loss curves, learning rate is an important one, but you'll get a sense for how different learning rates, which learning rates are good and bad. <span onclick="goVideo(this)" class="timestamp">77:08</span></p>
<p>So you'll see that if you have a very high exploding one, right, this is your loss explodes, then your learning rate is too high. <span onclick="goVideo(this)" class="timestamp">77:21</span></p>
<p>If it's too kind of linear and too flat, you'll see that it's too low, it's not changing enough. <span onclick="goVideo(this)" class="timestamp">77:28</span></p>
<p>And if you get something that looks like there's a steep change, but then a plateau, this is also an indicator of it being maybe too high, because in this case, you're taking too large jumps, and you're not able to settle well into your local optimum. <span onclick="goVideo(this)" class="timestamp">77:34</span></p>
<p>And so a good learning rate usually ends up looking something like this, where you have a relatively steep curve, but then it's continuing to go down, and then you might keep adjusting your learning rate from there. <span onclick="goVideo(this)" class="timestamp">77:49</span></p>
<p>And so this is something that you'll see through practice. <span onclick="goVideo(this)" class="timestamp">77:58</span></p>
<p>Okay and just, I think we're very close to the end, so just one last thing that I want to point out is than in case you ever see learning rate loss curves, where it's ... <span onclick="goVideo(this)" class="timestamp">78:04</span></p>
<p>So if you ever see loss curves where it's flat for a while, and then starts training all of a sudden, a potential reason could be bad initialization. <span onclick="goVideo(this)" class="timestamp">78:15</span></p>
<p>So in this case, your gradients are not really flowing too well the beginning, so nothing's really learning, and then at some point, it just happens to adjust in the right way, such that it tips over and things just start training right? <span onclick="goVideo(this)" class="timestamp">78:24</span></p>
<p>And so there's a lot of experience at looking at these and see what's wrong that you'll get over time. <span onclick="goVideo(this)" class="timestamp">78:36</span></p>
<p>And so you'll usually want to monitor and visualize your accuracy. <span onclick="goVideo(this)" class="timestamp">78:43</span></p>
<p>If you have a big gap between your training accuracy and your validation accuracy, it usually means that you might have overfitting and you might want to increase your regularization strength. <span onclick="goVideo(this)" class="timestamp">78:49</span></p>
<p>If you have no gap, you might want to increase your model capacity, because you haven't overfit yet. <span onclick="goVideo(this)" class="timestamp">79:00</span></p>
<p>You could potentially increase it more. <span onclick="goVideo(this)" class="timestamp">79:05</span></p>
<p>And in general, we also want to track the updates, the ratio of our weight updates to our weight magnitudes. <span onclick="goVideo(this)" class="timestamp">79:08</span></p>
<p>We can just take the norm of our parameters that we have to get a sense for how large they are, and when we have our update size, we can also take the norm of that, get a sense for how large that is, and we want this ratio to be somewhere around 0.001. <span onclick="goVideo(this)" class="timestamp">79:14</span></p>
<p>There's a lot of variance in this range, so you don't have to be exactly on this, but it's just this sense of you don't want your updates to be too large compared to your value or too small, right? <span onclick="goVideo(this)" class="timestamp">79:30</span></p>
<p>You don't want to dominate or to have no effect. <span onclick="goVideo(this)" class="timestamp">79:42</span></p>
<p>And so this is just something that can help debug what might be a problem. <span onclick="goVideo(this)" class="timestamp">79:44</span></p>
<p>Okay, so in summary, today we've looked at activation functions, data preprocessing, weight initialization, batch norm, babysitting the learning process, and hyperparameter optimization. <span onclick="goVideo(this)" class="timestamp">79:50</span></p>
<p>These are the kind of the takeaways for each that you guys should keep in mind. <span onclick="goVideo(this)" class="timestamp">80:02</span></p>
<p>Use ReLUs, subtract the mean, use Xavier Initialization, use batch norm, and sample hyperparameters randomly. <span onclick="goVideo(this)" class="timestamp">80:05</span></p>
<p>And next time we'll continue to talk about the training neural networks with all these different topics. <span onclick="goVideo(this)" class="timestamp">80:13</span></p>
<p>Thanks. <span onclick="goVideo(this)" class="timestamp">80:18</span></p>
		</div>
	</body>
</html>
