Lecture 8 - Deep Learning Software

Hello? 00:09
Okay, it's after 12, so I want to get started. 00:10
So today, lecture eight, we're going to talk about deep learning software. 00:13
This is a super exciting topic because it changes a lot every year. 00:17
But also means it's a lot of work to give this lecture 'cause it changes a lot every year. 00:21
But as usual, a couple administrative notes before we dive into the material. 00:25
So as a reminder the project proposals for your course projects were due on Tuesday. 00:30
So hopefully you all turned that in, and hopefully you all have a somewhat good idea of what kind of projects you want to work on for the class. 00:34
So we're in the process of assigning TA's to projects based on what the project area is and the expertise of the TA's. 00:42
So we'll have some more information about that in the next couple days I think. 00:50
We're also in the process of grading assignment one, so stay tuned and we'll get those grades back to you as soon as we can. 00:54
Another reminder is that assignment two has been out for a while. 01:00
That's going to be due next week, a week from today, Thursday. 01:04
And again, when working on assignment two, remember to stop your Google Cloud instances when you're not working to try to preserve your credits. 01:08
And another bit of confusion, I just wanted to re-emphasize is that for assignment two you really only need to use GPU instances for the last notebook. 01:16
For all of the several notebooks it's just in Python and Numpy so you don't need any GPUs for those questions. 01:24
So again, conserve your credits, only use GPUs when you need them. 01:32
And the final reminder is that the midterm is coming up. 01:36
It's kind of hard to believe we're there already, but the midterm will be in class on Tuesday, five nine. 01:39
So the midterm will be more theoretical. 01:45
It'll be sort of pen and paper working through different kinds of, slightly more theoretical questions to check your understanding of the material that we've covered so far. 01:47
And I think we'll probably post at least a short sort of sample of the types of questions to expect. 01:57
Question? 02:02
[student's words obscured due to lack of microphone] Oh yeah, question is whether it's open-book, so we're going to say closed note, closed book. 02:03
So just, Yeah, yeah, so that's what we've done in the past is just closed note, closed book, relatively just like want to check that you understand the intuition behind most of the stuff we've presented. 02:10
So, a quick recap as a reminder of what we were talking about last time. 02:23
Last time we talked about fancier optimization algorithms for deep learning models including SGD Momentum, Nesterov, RMSProp and Adam. 02:27
And we saw that these relatively small tweaks on top of vanilla SGD, are relatively easy to implement but can make your networks converge a bit faster. 02:34
We also talked about regularization, especially dropout. 02:45
So remember dropout, you're kind of randomly setting parts of the network to zero during the forward pass, and then you kind of marginalize out over that noise in the back at test time. 02:48
And we saw that this was kind of a general pattern across many different types of regularization in deep learning, where you might add some kind of noise during training, but then marginalize out that noise at test time so it's not stochastic at test time. 02:56
We also talked about transfer learning where you can maybe download big networks that were pre-trained on some dataset and then fine tune them for your own problem. 03:08
And this is one way that you can attack a lot of problems in deep learning, even if you don't have a huge dataset of your own. 03:15
So today we're going to shift gears a little bit and talk about some of the nuts and bolts about writing software and how the hardware works. 03:22
And a little bit, diving into a lot of details about what the software looks like that you actually use to train these things in practice. 03:29
So we'll talk a little bit about CPUs and GPUs and then we'll talk about several of the major deep learning frameworks that are out there in use these days. 03:36
So first, we've sort of mentioned this off hand a bunch of different times, that computers have CPUs, computers have GPUs. 03:45
Deep learning uses GPUs, but we weren't really too explicit up to this point about what exactly these things are and why one might be better than another for different tasks. 03:52
So, who's built a computer before? 04:02
Just kind of show of hands. 04:04
So, maybe about a third of you, half of you, somewhere around that ballpark. 04:06
So this is a shot of my computer at home that I built. 04:10
And you can see that there's a lot of stuff going on inside the computer, maybe, hopefully you know what most of these parts are. 04:15
And the CPU is the Central Processing Unit. 04:22
That's this little chip hidden under this cooling fan right here near the top of the case. 04:25
And the CPU is actually relatively small piece. 04:31
It's a relatively small thing inside the case. 04:34
It's not taking up a lot of space. 04:36
And the GPUs are these two big monster things that are taking up a gigantic amount of space in the case. 04:39
They have their own cooling, they're taking a lot of power. 04:46
They're quite large. 04:48
So, just in terms of how much power they're using, in terms of how big they are, the GPUs are kind of physically imposing and taking up a lot of space in the case. 04:50
So the question is what are these things and why are they so important for deep learning? 04:59
Well, the GPU is called a graphics card, or Graphics Processing Unit. 05:04
And these were really developed, originally for rendering computer graphics, and especially around games and that sort of thing. 05:08
So another show of hands, who plays video games at home sometimes, from time to time on their computer? 05:16
Yeah, so again, maybe about half, good fraction. 05:23
So for those of you who've played video games before and who've built your own computers, you probably have your own opinions on this debate. 05:25
[laughs] So this is one of those big debates in computer science. 05:32
You know, there's like Intel versus AMD, NVIDIA versus AMD for graphics cards. 05:37
It's up there with Vim versus Emacs for text editor. 05:42
And pretty much any gamer has their own opinions on which of these two sides they prefer for their own cards. 05:45
And in deep learning we kind of have mostly picked one side of this fight, and that's NVIDIA. 05:51
So if you guys have AMD cards, you might be in a little bit more trouble if you want to use those for deep learning. 05:59
And really, NVIDIA's been pushing a lot for deep learning in the last several years. 06:05
It's been kind of a large focus of some of their strategy. 06:08
And they put in a lot effort into engineering sort of good solutions to make their hardware better suited for deep learning. 06:11
So most people in deep learning when we talk about GPUs, we're pretty much exclusively talking about NVIDIA GPUs. 06:19
Maybe in the future this'll change a little bit, and there might be new players coming up, but at least for now NVIDIA is pretty dominant. 06:27
So to give you an idea of like what is the difference between a CPU and a GPU, I've kind of made a little spread sheet here. 06:35
On the top we have two of the kind of top end Intel consumer CPUs, and on the bottom we have two of NVIDIA's sort of current top end consumer GPUs. 06:41
And there's a couple general trends to notice here. 06:52
Both GPUs and CPUs are kind of a general purpose computing machine where they can execute programs and do sort of arbitrary instructions, but they're qualitatively pretty different. 06:55
So CPUs tend to have just a few cores, for consumer desktop CPUs these days, they might have something like four or six or maybe up to 10 cores. 07:05
With hyperthreading technology that means they can run, the hardware can physically run, like maybe eight or up to 20 threads concurrently. 07:16
So the CPU can maybe do 20 things in parallel at once. 07:24
So that's just not a gigantic number, but those threads for a CPU are pretty powerful. 07:29
They can actually do a lot of things, they're very fast. 07:34
Every CPU instruction can actually do quite a lot of stuff. 07:37
And they can all work pretty independently. 07:39
For GPUs it's a little bit different. 07:43
So for GPUs we see that these sort of common top end consumer GPUs have thousands of cores. 07:45
So the NVIDIA Titan XP which is the current top of the line consumer GPU has 3840 cores. 07:51
So that's a crazy number. 08:00
That's like way more than the 10 cores that you'll get for a similarly priced CPU. 08:02
The downside of a GPU is that each of those cores, one, it runs at a much slower clock speed. 08:06
And two they really can't do quite as much. 08:12
You can't really compare CPU cores and GPU cores apples to apples. 08:14
The GPU cores can't really operate very independently. 08:19
They all kind of need to work together and sort of paralyze one task across many cores rather than each core totally doing its own thing. 08:22
So you can't really compare these numbers directly. 08:29
But it should give you the sense that due to the large number of cores GPUs can sort of, are really good for parallel things where you need to do a lot of things all at the same time, but those things are all pretty much the same flavor. 08:32
Another thing to point out between CPUs and GPUs is this idea of memory. 08:44
Right, so CPUs have some cache on the CPU, but that's relatively small and the majority of the memory for your CPU is pulling from your system memory, the RAM, which will maybe be like eight, 12, 16, 32 gigabytes of RAM on a typical consumer desktop these days. 08:49
Whereas GPUs actually have their own RAM built into the chip. 09:06
There's a pretty large bottleneck communicating between the RAM in your system and the GPU, so the GPUs typically have their own relatively large block of memory within the card itself. 09:12
And for the Titan XP, which again is maybe the current top of the line consumer card, this thing has 12 gigabytes of memory local to the GPU. 09:23
GPUs also have their own caching system where there are sort of multiple hierarchies of caching between the 12 gigabytes of GPU memory and the actual GPU cores. 09:33
And that's somewhat similar to the caching hierarchy that you might see in a CPU. 09:41
So, CPUs are kind of good for general purpose processing. 09:47
They can do a lot of different things. 09:50
And GPUs are maybe more specialized for these highly paralyzable algorithms. 09:52
So the prototypical algorithm of something that works really really well and is like perfectly suited to a GPU is matrix multiplication. 09:57
So remember in matrix multiplication on the left we've got like a matrix composed of a bunch of rows. 10:04
We multiply that on the right by another matrix composed of a bunch of columns and then this produces another, a final matrix where each element in the output matrix is a dot product between one of the rows and one of the columns of the two input matrices. 10:09
And these dot products are all independent. 10:22
Like you could imagine, for this output matrix you could split it up completely and have each of those different elements of the output matrix all being computed in parallel and they all sort of are running the same computation which is taking a dot product of these two vectors. 10:25
But exactly where they're reading that data from is from different places in the two input matrices. 10:38
So you could imagine that for a GPU you can just like blast this out and have all of this elements of the output matrix all computed in parallel and that could make this thing computer super super fast on GPU. 10:44
So that's kind of the prototypical type of problem that like where a GPU is really well suited, where a CPU might have to go in and step through sequentially and compute each of these elements one by one. 10:55
That picture is a little bit of a caricature because CPUs these days have multiple cores, they can do vectorized instructions as well, but still, for these like massively parallel problems GPUs tend to have much better throughput. 11:06
Especially when these matrices get really really big. 11:19
And by the way, convolution is kind of the same kind of story. 11:21
Where you know in convolution we have this input tensor, we have this weight tensor and then every point in the output tensor after a convolution is again some inner product between some part of the weights and some part of the input. 11:25
And you can imagine that a GPU could really paralyze this computation, split it all up across the many cores and compute it very quickly. 11:36
So that's kind of the general flavor of the types of problems where GPUs give you a huge speed advantage over CPUs. 11:43
So you can actually write programs that run directly on GPUs. 11:51
So NVIDIA has this CUDA abstraction that lets you write code that kind of looks like C, but executes directly on the GPUs. 11:55
But CUDA code is really really tricky. 12:03
It's actually really tough to write CUDA code that's performant and actually squeezes all the juice out of these GPUs. 12:05
You have to be very careful managing the memory hierarchy and making sure you don't have cache misses and branch mispredictions and all that sort of stuff. 12:12
So it's actually really really hard to write performant CUDA code on your own. 12:19
So as a result NVIDIA has released a lot of libraries that implement common computational primitives that are very very highly optimized for GPUs. 12:22
So for example NVIDIA has a cuBLAS library that implements different kinds of matrix multiplications and different matrix operations that are super optimized, run really well on GPU, get very close to sort of theoretical peak hardware utilization. 12:32
Similarly they have a cuDNN library which implements things like convolution, forward and backward passes, batch normalization, recurrent networks, all these kinds of computational primitives that we need in deep learning. 12:46
NVIDIA has gone in there and released their own binaries that compute these primitives very efficiently on NVIDIA hardware. 12:57
So in practice, you tend not to end up writing your own CUDA code for deep learning. 13:03
You typically are just mostly calling into existing code that other people have written. 13:09
Much of which is the stuff which has been heavily optimized by NVIDIA already. 13:14
There's another sort of language called OpenCL which is a bit more general. 13:19
Runs on more than just NVIDIA GPUs, can run on AMD hardware, can run on CPUs, but OpenCL, nobody's really spent a really large amount of effort and energy trying to get optimized deep learning primitives for OpenCL, so it tends to be a lot less performant the super optimized versions in CUDA. 13:23
So maybe in the future we might see a bit of a more open standard and we might see this across many different more types of platforms, but at least for now, NVIDIA's kind of the main game in town for deep learning. 13:43
So you can check, there's a lot of different resources for learning about how you can do GPU programming yourself. 13:55
It's kind of fun. 14:00
It's sort of a different paradigm of writing code because it's this massively parallel architecture, but that's a bit beyond the scope of this course. 14:01
And again, you don't really need to write your own CUDA code much in practice for deep learning. 14:08
And in fact, I've never written my own CUDA code for any research project, so, but it is kind of useful to know like how it works and what are the basic ideas even if you're not writing it yourself. 14:12
So if you want to look at kind of CPU GPU performance in practice, I did some benchmarks last summer comparing a decent Intel CPU against a bunch of different GPUs that were sort of near top of the line at that time. 14:23
And these were my own benchmarks that you can find more details on GitHub, but my findings were that for things like VGG 16 and 19, ResNets, various ResNets, then you typically see something like a 65 to 75 times speed up when running the exact same computation on a top of the line GPU, in this case a Pascal Titan X, versus a top of the line, well, not quite top of the line CPU, which in this case was an Intel E5 processor. 14:38
Although, I'd like to make one sort of caveat here is that you always need to be super careful whenever you're reading any kind of benchmarks about deep learning, because it's super easy to be unfair between different things. 15:08
And you kind of need to know a lot of the details about what exactly is being benchmarked in order to know whether or not the comparison is fair. 15:20
So in this case I'll come right out and tell you that probably this comparison is a little bit unfair to CPU because I didn't spend a lot of effort trying to squeeze the maximal performance out of CPUs. 15:26
I probably could have tuned the blast libraries better for the CPU performance. 15:38
And I probably could have gotten these numbers a bit better. 15:42
This was sort of out of the box performance between just installing Torch, running it on a CPU, just installing Torch running it on a GPU. 15:44
So this is kind of out of the box performance, but it's not really like peak, possible, theoretical throughput on the CPU. 15:51
But that being said, I think there are still pretty substantial speed ups to be had here. 15:57
Another kind of interesting outcome from this benchmarking was comparing these optimized cuDNN libraries from NVIDIA for convolution and whatnot versus sort of more naive CUDA that had been hand written out in the open source community. 16:02
And you can see that if you compare the same networks on the same hardware with the same deep learning framework and the only difference is swapping out these cuDNN versus sort of hand written, less optimized CUDA you can see something like nearly a three X speed up across the board when you switch from the relatively simple CUDA to these like super optimized cuDNN implementations. 16:17
So in general, whenever you're writing code on GPU, you should probably almost always like just make sure you're using cuDNN because you're leaving probably a three X performance boost on the table if you're not calling into cuDNN for your stuff. 16:37
So another problem that comes up in practice, when you're training these things is that you know, your model is maybe sitting on the GPU, the weights of the model are in that 12 gigabytes of local storage on the GPU, but your big dataset is sitting over on the right on a hard drive or an SSD or something like that. 16:51
So if you're not careful you can actually bottleneck your training by just trying to read the data off the disk. 17:07
'Cause the GPU is super fast, it can compute forward and backward quite fast, but if you're reading sequentially off a spinning disk, you can actually bottleneck your training quite, and that can be really bad and slow you down. 17:14
So some solutions here are that like you know if your dataset's really small, sometimes you might just read the whole dataset into RAM. 17:25
Or even if your dataset isn't so small, but you have a giant server with a ton of RAM, you might do that anyway. 17:31
You can also make sure you're using an SSD instead of a hard drive, that can help a lot with read throughput. 17:36
Another common strategy is to use multiple threads on the CPU that are pre-fetching data off RAM or off disk, buffering it in memory, in RAM so that then you can continue feeding that buffer data down to the GPU with good performance. 17:42
This is a little bit painful to set up, but again like, these GPU's are so fast that if you're not really careful with trying to feed them data as quickly as possible, just reading the data can sometimes bottleneck the whole training process. 17:57
So that's something to be aware of. 18:08
So that's kind of the brief introduction to like sort of GPU CPU hardware in practice when it comes to deep learning. 18:11
And then I wanted to switch gears a little bit and talk about the software side of things. 18:17
The various deep learning frameworks that people are using in practice. 18:21
But I guess before I move on, is there any sort of questions about CPU GPU? 18:25
Yeah, question? 18:28
[student's words obscured due to lack of microphone] Yeah, so the question is what can you sort of, what can you do mechanically when you're coding to avoid these problems? 18:30
Probably the biggest thing you can do in software is set up sort of pre-fetching on the CPU. 18:45
Like you couldn't like, sort of a naive thing would be you have this sequential process where you first read data off disk, wait for the data, wait for the minibatch to be read, then feed the minibatch to the GPU, then go forward and backward on the GPU, then read another minibatch and sort of do this all in sequence. 18:50
And if you actually have multiple, like instead you might have CPU threads running in the background that are fetching data off the disk such that while the, you can sort of interleave all of these things. 19:06
Like the GPU is computing, the CPU background threads are feeding data off disk and your main thread is kind of waiting for these things to, just doing a bit of synchronization between these things so they're all happening in parallel. 19:17
And thankfully if you're using some of these deep learning frameworks that we're about to talk about, then some of this work has already been done for you 'cause it's a little bit painful. 19:28
So the landscape of deep learning frameworks is super fast moving. 19:38
So last year when I gave this lecture I talked mostly about Caffe, Torch, Theano and TensorFlow. 19:41
And when I last gave this talk, again more than a year ago, TensorFlow was relatively new. 19:47
It had not seen super widespread adoption yet at that time. 19:53
But now I think in the last year TensorFlow has gotten much more popular. 19:57
It's probably the main framework of choice for many people. 20:01
So that's a big change. 20:04
We've also seen a ton of new frameworks sort of popping up like mushrooms in the last year. 20:07
So in particular Caffe2 and PyTorch are new frameworks from Facebook that I think are pretty interesting. 20:12
There's also a ton of other frameworks. 20:18
Paddle, Baidu has Paddle, Microsoft has CNTK, Amazon is mostly using MXNet and there's a ton of other frameworks as well, but I'm less familiar with, and really don't have time to get into. 20:20
But one interesting thing to point out from this picture is that kind of the first generation of deep learning frameworks that really saw wide adoption were built in academia. 20:33
So Caffe was from Berkeley, Torch was developed originally NYU and also in collaboration with Facebook. 20:43
And Theana was mostly build at the University of Montreal. 20:49
But these kind of next generation deep learning frameworks all originated in industry. 20:52
So Caffe2 is from Facebook, PyTorch is from Facebook. 20:56
TensorFlow is from Google. 20:58
So it's kind of an interesting shift that we've seen in the landscape over the last couple of years is that these ideas have really moved a lot from academia into industry. 21:00
And now industry is kind of giving us these big powerful nice frameworks to work with. 21:08
So today I wanted to mostly talk about PyTorch and TensorFlow 'cause I personally think that those are probably the ones you should be focusing on for a lot of research type problems these days. 21:14
I'll also talk a bit about Caffe and Caffe2. 21:24
But probably a little bit less emphasis on those. 21:28
And before we move any farther, I thought I should make my own biases a little bit more explicit. 21:32
So I have mostly, I've worked with Torch mostly for the last several years. 21:36
And I've used it quite a lot, I like it a lot. 21:40
And then in the last year I've mostly switched to PyTorch as my main research framework. 21:43
So I have a little bit less experience with some of these others, especially TensorFlow, but I'll still try to do my best to give you a fair picture and a decent overview of these things. 21:48
So, remember that in the last several lectures we've hammered this idea of computational graphs in sort of over and over. 21:58
That whenever you're doing deep learning, you want to think about building some computational graph that computes whatever function that you want to compute. 22:06
So in the case of a linear classifier you'll combine your data X and your weights W with a matrix multiply. 22:13
You'll do some kind of hinge loss to maybe have, compute your loss. 22:18
You'll have some regularization term and you imagine stitching together all these different operations into some graph structure. 22:22
Remember that these graph structures can get pretty complex in the case of a big neural net, now there's many different layers, many different activations. 22:28
Many different weights spread all around in a pretty complex graph. 22:36
And as you move to things like neural turing machines then you can get these really crazy computational graphs that you can't even really draw because they're so big and messy. 22:39
So the point of deep learning frameworks is really, there's really kind of three main reasons why you might want to use one of these deep learning frameworks rather than just writing your own code. 22:48
So the first would be that these frameworks enable you to easily build and work with these big hairy computational graphs without kind of worrying about a lot of those bookkeeping details yourself. 22:58
Another major idea is that, whenever we're working in deep learning we always need to compute gradients. 23:08
We're always computing some loss, we're always computer gradient of our weight with respect to the loss. 23:14
And we'd like to make this automatically computing gradient, you don't want to have to write that code yourself. 23:18
You want that framework to handle all these back propagation details for you so you can just think about writing down the forward pass of your network and have the backward pass sort of come out for free without any additional work. 23:26
And finally you want all this stuff to run efficiently on GPUs so you don't have to worry too much about these low level hardware details about cuBLAS and cuDNN and CUDA and moving data between the CPU and GPU memory. 23:36
You kind of want all those messy details to be taken care of for you. 23:48
So those are kind of some of the major reasons why you might choose to use frameworks rather than writing your own stuff from scratch. 23:52
So as kind of a concrete example of a computational graph we can maybe write down this super simple thing. 23:59
Where we have three inputs, X, Y, and Z. 24:05
We're going to combine X and Y to produce A. 24:08
Then we're going to combine A and Z to produce B and then finally we're going to do some maybe summing out operation on B to give some scaler final result C. 24:09
So you've probably written enough Numpy code at this point to realize that it's super easy to write down, to implement this computational graph, or rather to implement this bit of computation in Numpy, right? 24:18
You can just kind of write down in Numpy that you want to generate some random data, you want to multiply two things, you want to add two things, you want to sum out a couple things. 24:31
And it's really easy to do this in Numpy. 24:38
But then the question is like suppose that we want to compute the gradient of C with respect to X, Y, and Z. 24:41
So, if you're working in Numpy, you kind of need to write out this backward pass yourself. 24:48
And you've gotten a lot of practice with this on the homeworks, but it can be kind of a pain and a little bit annoying and messy once you get to really big complicated things. 24:52
The other problem with Numpy is that it doesn't run on the GPU. 25:02
So Numpy is definitely CPU only. 25:05
And you're never going to be able to experience or take advantage of these GPU accelerated speedups if you're stuck working in Numpy. 25:08
And it's, again, it's a pain to have to compute your own gradients in all these situations. 25:14
So, kind of the goal of most deep learning frameworks these days is to let you write code in the forward pass that looks very similar to Numpy, but lets you run it on the GPU and lets you automatically compute gradients. 25:19
And that's kind of the big picture goal of most of these frameworks. 25:33
So if you imagine looking at, if we look at an example in TensorFlow of the exact same computational graph, we now see that in this forward pass, you write this code that ends up looking very very similar to the Numpy forward pass where you're kind of doing these multiplication and these addition operations. 25:36
But now TensorFlow has this magic line that just computes all the gradients for you. 25:52
So now you don't have go in and write your own backward pass and that's much more convenient. 25:57
The other nice thing about TensorFlow is you can really just, like with one line you can switch all this computation between CPU and GPU. 26:02
So here, if you just add this with statement before you're doing this forward pass, you just can explicitly tell the framework, hey I want to run this code on the CPU. 26:08
But now if we just change that with statement a little bit with just with a one character change in this case, changing that C to a G, now the code runs on GPU. 26:16
And now in this little code snippet, we've solved these two problems. 26:24
We're running our code on the GPU and we're having the framework compute all the gradients for us, so that's really nice. 26:29
And PyTorch kind looks almost exactly the same. 26:35
So again, in PyTorch you kind of write down, you define some variables, you have some forward pass and the forward pass again looks very similar to like, in this case identical to the Numpy code. 26:38
And then again, you can just use PyTorch to compute gradients, all your gradients with just one line. 26:49
And now in PyTorch again, it's really easy to switch to GPU, you just need to cast all your stuff to the CUDA data type before you rung your computation and now everything runs transparently on the GPU for you. 26:56
So if you kind of just look at these three examples, these three snippets of code side by side, the Numpy, the TensorFlow and the PyTorch you see that the TensorFlow and the PyTorch code in the forward pass looks almost exactly like Numpy which is great 'cause Numpy has a beautiful API, it's really easy to work with. 27:06
But we can compute gradients automatically and we can run the GPU automatically. 27:24
So after that kind of introduction, I wanted to dive in and talk in a little bit more detail about kind of what's going on inside this TensorFlow example. 27:30
So as a running example throughout the rest of the lecture, I'm going to use the training a two-layer fully connected ReLU network on random data as kind of a running example throughout the rest of the examples here. 27:37
And we're going to train this thing with an L2 Euclidean loss on random data. 27:50
So this is kind of a silly network, it's not really doing anything useful, but it does give you the, it's relatively small, self contained, the code fits on the slide without being too small, and it lets you demonstrate kind of a lot of the useful ideas inside these frameworks. 27:55
So here on the right, oh, and then another note, I'm kind of assuming that Numpy and TensorFlow have already been imported in all these code snippets. 28:08
So in TensorFlow you would typically divide your computation into two major stages. 28:15
First, we're going to write some code that defines our computational graph, and that's this red code up in the top half. 28:21
And then after you define your graph, you're going to run the graph over and over again and actually feed data into the graph to perform whatever computation you want it to perform. 28:28
So this is the really, this is kind of the big common pattern in TensorFlow. 28:36
You'll first have a bunch of code that builds the graph and then you'll go and run the graph and reuse it many many times. 28:40
So if you kind of dive into the code of building the graph in this case. 28:48
Up at the top you see that we're defining this X, Y, w1 and w2, and we're creating these tf.placeholder objects. 28:52
So these are going to be input nodes to the graph. 29:01
These are going to be sort of entry points to the graph where when we run the graph, we're going to feed in data and put them in through these input slots in our computational graph. 29:05
So this is not actually like allocating any memory right now. 29:15
We're just sort of setting up these input slots to the graph. 29:19
Then we're going to use those input slots which are now kind of like these symbolic variables and we're going to perform different TensorFlow operations on these symbolic variables in order to set up what computation we want to run on those variables. 29:23
So in this case we're doing a matrix multiplication between X and w1, we're doing some tf.maximum to do a ReLU nonlinearity and then we're doing another matrix multiplication to compute our output predictions. 29:37
And then we're again using a sort of basic Tensor operations to compute our Euclidean distance, our L2 loss between our prediction and the target Y. 29:49
Another thing to point out here is that these lines of code are not actually computing anything. 29:58
There's no data in the system right now. 30:03
We're just building up this computational graph data structure telling TensorFlow which operations we want to eventually run once we put in real data. 30:05
So this is just building the graph, this is not actually doing anything. 30:15
Then we have this magical line where after we've computed our loss with these symbolic operations, then we can just ask TensorFlow to compute the gradient of the loss with respect to w1 and w2 in this one magical, beautiful line. 30:18
And this avoids you writing all your own backprop code that you had to do in the assignments. 30:33
But again there's no actual computation happening here. 30:37
This is just sort of adding extra operations to the computational graph where now the computational graph has these additional operations which will end up computing these gradients for you. 30:40
So now at this point we've computed our computational graph, we have this big graph in this graph data structure in memory that knows what operations we want to perform to compute the loss in gradients. 30:51
And now we enter a TensorFlow session to actually run this graph and feed it with data. 31:01
So then, once we've entered the session, then we actually need to construct some concrete values that will be fed to the graph. 31:06
So TensorFlow just expects to receive data from Numpy arrays in most cases. 31:13
So here we're just creating concrete actual values for X, Y, w1 and w2 using Numpy and then storing these in some dictionary. 31:19
And now here is where we're actually running the graph. 31:30
So you can see that we're calling a session.run to actually execute some part of the graph. 31:32
The first argument loss, tells us which part of the graph do we actually want as output. 31:38
And that, so we actually want the graph, in this case we need to tell it that we actually want to compute loss and grad1 and grad w2 and we need to pass in with this feed dict parameter the actual concrete values that will be fed to the graph. 31:43
And then after, in this one line, it's going and running the graph and then computing those values for loss grad1 to grad w2 and then returning the actual concrete values for those in Numpy arrays again. 31:57
So now after you unpack this output in the second line, you get Numpy arrays, or you get Numpy arrays with the loss and the gradients. 32:12
So then you can go and do whatever you want with these values. 32:19
So then, this has only run sort of one forward and backward pass through our graph, and it only takes a couple extra lines if we actually want to train the network. 32:23
So here we're, now we're running the graph many times in a loop so we're doing a four loop and in each iteration of the loop, we're calling session.run asking it to compute the loss and the gradients. 32:33
And now we're doing a manual gradient discent step using those computed gradients to now update our current values of the weights. 32:45
So if you actually run this code and plot the losses, then you'll see that the loss goes down and the network is training and this is working pretty well. 32:52
So this is kind of like a super bare bones example of training a fully connected network in TensorFlow. 33:00
But there's a problem here. 33:06
So here, remember that on the forward pass, every time we execute this graph, we're actually feeding in the weights. 33:08
We have the weights as Numpy arrays and we're explicitly feeding them into the graph. 33:15
And now when the graph finishes executing it's going to give us these gradients. 33:18
And remember the gradients are the same size as the weights. 33:23
So this means that every time we're running the graph here, we're copying the weights from Numpy arrays into TensorFlow then getting the gradients and then copying the gradients from TensorFlow back out to Numpy arrays. 33:26
So if you're just running on CPU, this is maybe not a huge deal, but remember we talked about CPU GPU bottleneck and how it's very expensive actually to copy data between CPU memory and GPU memory. 33:36
So if your network is very large and your weights and gradients were very big, then doing something like this would be super expensive and super slow because we'd be copying all kinds of data back and forth between the CPU and the GPU at every time step. 33:47
So that's bad, we don't want to do that. 33:59
We need to fix that. 34:00
So, obviously TensorFlow has some solution to this. 34:01
And the idea is that now we want our weights, w1 and w2, rather than being placeholders where we're going to, where we expect to feed them in to the network on every forward pass, instead we define them as variables. 34:06
So a variable is something is a value that lives inside the computational graph and it's going to persist inside the computational graph across different times when you run the same graph. 34:17
So now instead of declaring these w1 and w2 as placeholders, instead we just construct them as variables. 34:27
But now since they live inside the graph, we also need to tell TensorFlow how they should be initialized, right? 34:33
Because in the previous case we were feeding in their values from outside the graph, so we initialized them in Numpy, but now because these things live inside the graph, TensorFlow is responsible for initializing them. 34:39
So we need to pass in a tf.randomnormal operation, which again is not actually initializing them when we run this line, this is just telling TensorFlow how we want them to be initialized. 34:50
So it's a little bit of confusing misdirection going on here. 35:00
And now, remember in the previous example we were actually updating the weights outside of the computational graph. 35:04
We, in the previous example, we were computing the gradients and then using them to update the weights as Numpy arrays and then feeding in the updated weights at the next time step. 35:11
But now because we want these weights to live inside the graph, this operation of updating the weights needs to also be an operation inside the computational graph. 35:20
So now we used this assign function which mutates these variables inside the computational graph and now the mutated value will persist across multiple runs of the same graph. 35:29
So now when we run this graph and when we train the network, now we need to run the graph once with a little bit of special incantation to tell TensorFlow to set up these variables that are going to live inside the graph. 35:41
And then once we've done that initialization, now we can run the graph over and over again. 35:53
And here, we're now only feeding in the data and labels X and Y and the weights are living inside the graph. 35:58
And here we've asked the network to, we've asked TensorFlow to compute the loss for us. 36:05
And then you might think that this would train the network, but there's actually a bug here. 36:09
So, if you actually run this code, and you plot the loss, it doesn't train. 36:15
So that's bad, it's confusing, like what's going on? 36:19
We wrote this assign code, we ran the thing, like we computed the loss and the gradients and our loss is flat, what's going on? 36:23
Any ideas? 36:29
[student's words obscured due to lack of microphone] Yeah so one hypothesis is that maybe we're accidentally re-initializing the w's every time we call the graph. 36:31
That's a good hypothesis, that's actually not the problem in this case. 36:41
[student's words obscured due to lack of microphone] Yeah, so the answer is that we actually need to explicitly tell TensorFlow that we want to run these new w1 and new w2 operations. 36:44
So we've built up this big computational graph data structure in memory and now when we call run, we only told TensorFlow that we wanted to compute loss. 36:56
And if you look at the dependencies among these different operations inside the graph, you see that in order to compute loss we don't actually need to perform this update operation. 37:04
So TensorFlow is smart and it only computes the parts of the graph that are necessary for computing the output that you asked it to compute. 37:13
So that's kind of a nice thing because it means it's only doing as much work as it needs to, but in situations like this it can be a little bit confusing and lead to behavior that you didn't expect. 37:21
So the solution in this case is that we actually need to explicitly tell TensorFlow to perform those update operations. 37:32
So one thing we could do, which is what was suggested is we could add new w1 and new w2 as outputs and just tell TensorFlow that we want to produce these values as outputs. 37:39
But that's a problem too because the values, those new w1, new w2 values are again these big tensors. 37:49
So now if we tell TensorFlow we want those as output, we're going to again get this copying behavior between CPU and GPU at ever iteration. 37:58
So that's bad, we don't want that. 38:05
So there's a little trick you can do instead. 38:07
Which is that we add kind of a dummy node to the graph. 38:09
With these fake data dependencies and we just say that this dummy node updates, has these data dependencies of new w1 and new w2. 38:11
And now when we actually run the graph, we tell it to compute both the loss and this dummy node. 38:20
And this dummy node doesn't actually return any value it just returns none, but because of this dependency that we've put into the node it ensures that when we run the updates value, we actually also run these update operations. 38:25
So, question? 38:38
[student's words obscured due to lack of microphone] Is there a reason why we didn't put X and Y into the graph? 38:40
And that it stayed as Numpy. 38:48
So in this example we're reusing X and Y on every, we're reusing the same X and Y on every iteration. 38:51
So you're right, we could have just also stuck those in the graph, but in a more realistic scenario, X and Y will be minibatches of data so those will actually change at every iteration and we will want to feed different values for those at every iteration. 38:57
So in this case, they could have stayed in the graph, but in most cases they will change, so we don't want them to live in the graph. 39:10
Oh, another question? 39:19
[student's words obscured due to lack of microphone] Yeah, so we've told it, we had put into TensorFlow that the outputs we want are loss and updates. 39:21
Updates is not actually a real value. 39:44
So when updates evaluates it just returns none. 39:48
But because of this dependency we've told it that updates depends on these assign operations. 39:51
But these assign operations live inside the computational graph and all live inside GPU memory. 39:57
So then we're doing these update operations entirely on the GPU and we're no longer copying the updated values back out of the graph. 40:02
[student's words obscured due to lack of microphone] So the question is does tf.group return none? 40:11
So this gets into the trickiness of TensorFlow. 40:18
So tf.group returns some crazy TensorFlow value. 40:21
It sort of returns some like internal TensorFlow node operation that we need to continue building the graph. 40:25
But when you execute the graph, and when you tell, inside the session.run, when we told it we want it to compute the concrete value from updates, then that returns none. 40:32
So whenever you're working with TensorFlow you have this funny indirection between building the graph and the actual output values during building the graph is some funny weird object, and then you actually get a concrete value when you run the graph. 40:43
So here after you run updates, then the output is none. 40:55
Does that clear it up a little bit? 40:58
[student's words obscured due to lack of microphone] So the question is why is loss a value and why is updates none? 40:59
That's just the way that updates works. 41:22
So loss is a value when we compute, when we tell TensorFlow we want to run a tensor, then we get the concrete value. 41:24
Updates is this kind of special other data type that does not return a value, it instead returns none. 41:30
So it's kind of some TensorFlow magic that's going on there. 41:35
Maybe we can talk offline if you're still confused. 41:38
[student's words obscured due to lack of microphone] Yeah, yeah, that behavior is coming from the group method. 41:40
So now, we kind of have this weird pattern where we wanted to do these different assign operations, we have to use this funny tf.group thing. 41:46
That's kind of a pain, so thankfully TensorFlow gives you some convenience operations that kind of do that kind of stuff for you. 41:52
And that's called an optimizer. 42:00
So here we're using a tf.train.GradientDescentOptimizer and we're telling it what learning rate we want to use. 42:01
And you can imagine that there's, there's RMSprop, there's all kinds of different optimization algorithms here. 42:08
And now we call optimizer.minimize of loss and now this is a pretty magical, this is a pretty magical thing, because now this call is aware that these variables w1 and w2 are marked as trainable by default, so then internally, inside this optimizer.minimize it's going in and adding nodes to the graph which will compute gradient of loss with respect to w1 and w2 and then it's also performing that update operation for you and it's doing the grouping operation for you and it's doing the assigns. 42:12
It's like doing a lot of magical stuff inside there. 42:42
But then it ends up giving you this magical updates value which, if you dig through the code they're actually using tf.group so it looks very similar internally to what we saw before. 42:44
And now when we run the graph inside our loop we do the same pattern of telling it to compute loss and updates. 42:53
And every time we tell the graph to compute updates, then it'll actually go and update the graph. 43:00
Question? 43:07
[student's words obscured due to lack of microphone] Yeah, so what is the tf.GlobalVariablesInitializer? 43:08
So that's initializing w1 and w2 because these are variables which live inside the graph. 43:14
So we need to, when we saw this, when we create the tf.variable we have this tf.randomnormal which is this initialization so the tf.GlobalVariablesInitializer is causing the tf.randomnormal to actually run and generate concrete values to initialize those variables. 43:20
[student's words obscured due to lack of microphone] Sorry, what was the question? 43:37
[student's words obscured due to lack of microphone] So it knows that a placeholder is going to be fed outside of the graph and a variable is something that lives inside the graph. 43:42
So I don't know all the details about how it decides, what exactly it decides to run with that call. 43:51
I think you'd need to dig through the code to figure that out, or maybe it's documented somewhere. 43:56
So but now we've kind of got this, again we've got this full example of training a network in TensorFlow and we're kind of adding bells and whistles to make it a little bit more convenient. 44:00
So we can also here, in the previous example we were computing the loss explicitly using our own tensor operations, TensorFlow you can always do that, you can use basic tensor operations to compute just about anything you want. 44:09
But TensorFlow also gives you a bunch of convenience functions that compute these common neural network things for you. 44:20
So in this case we can use tf.losses.mean_squared_error and it just does the L2 loss for us so we don't have to compute it ourself in terms of basic tensor operations. 44:26
So another kind of weirdness here is that it was kind of annoying that we had to explicitly define our inputs and define our weights and then like chain them together in the forward pass using a matrix multiply. 44:36
And in this example we've actually not put biases in the layer because that would be kind of an extra, then we'd have to initialize biases, we'd have to get them in the right shape, we'd have to broadcast the biases against the output of the matrix multiply and you can see that that would kind of be a lot of code. 44:46
It would be kind of annoying write. 45:01
And once you get to like convolutions and batch normalizations and other types of layers this kind of basic way of working, of having these variables, having these inputs and outputs and combining them all together with basic computational graph operations could be a little bit unwieldy and it could be really annoying to make sure you initialize the weights with the right shapes and all that sort of stuff. 45:03
So as a result, there's a bunch of sort of higher level libraries that wrap around TensorFlow and handle some of these details for you. 45:22
So one example that ships with TensorFlow, is this tf.layers inside. 45:30
So now in this code example you can see that our code is only explicitly declaring the X and the Y which are the placeholders for the data and the labels. 45:35
And now we say that H=tf.layers.dense, we give it the input X and we tell it units=H. 45:44
This is again kind of a magical line because inside this line, it's kind of setting up w1 and b1, the bias, it's setting up variables for those with the right shapes that are kind of inside the graph but a little bit hidden from us. 45:53
And it's using this xavier initializer object to set up an initialization strategy for those. 46:07
So before we were doing that explicitly ourselves with the tf.randomnormal business, but now here it's kind of handling some of those details for us and it's just spitting out an H, which is again the same sort of H that we saw in the previous layer, it's just doing some of those details for us. 46:12
And you can see here, we're also passing an activation=tf.nn.relu so it's even doing the activation, the relu activation function inside this layer for us. 46:28
So it's taking care of a lot of these architectural details for us. 46:36
Question? 46:41
[student's words obscured due to lack of microphone] Question is does the xavier initializer default to particular distribution? 46:42
I'm sure it has some default, I'm not sure what it is. 46:51
I think you'll have to look at the documentation. 46:53
But it seems to be a reasonable strategy, I guess. 46:55
And in fact if you run this code, it converges much faster than the previous one because the initialization is better. 46:58
And you can see that we're using two calls to tf.layers and this lets us build our model without doing all these explicit bookkeeping details ourself. 47:04
So this is maybe a little bit more convenient. 47:11
But tf.contrib.layer is really not the only game in town. 47:14
There's like a lot of different higher level libraries that people build on top of TensorFlow. 47:18
And it's kind of due to this basic impotence mis-match where the computational graph is relatively low level thing, but when we're working with neural networks we have this concept of layers and weights and some layers have weights associated with them, and we typically think at a slightly higher level of abstraction than this raw computational graph. 47:23
So that's what these various packages are trying to help you out and let you work at this higher layer of abstraction. 47:41
So another very popular package that you may have seen before is Keras. 47:48
Keras is a very beautiful, nice API that sits on top of TensorFlow and handles sort of building up these computational graph for you up in the back end. 47:52
By the way, Keras also supports Theano as a back end, so that's also kind of nice. 48:02
And in this example you can see we build the model as a sequence of layers. 48:07
We build some optimizer object and we call model.compile and this does a lot of magic in the back end to build the graph. 48:10
And now we can call model.fit and that does the whole training procedure for us magically. 48:17
So I don't know all the details of how this works, but I know Keras is very popular, so you might consider using it if you're talking about TensorFlow. 48:22
Question? 48:29
[student's words obscured due to lack of microphone] Yeah, so the question is like why there's no explicit CPU, GPU going on here. 48:31
So I've kind of left that out to keep the code clean. 48:45
But you saw at the beginning examples it was pretty easy to flop all these things between CPU and GPU and there was either some global flag or some different data type or some with statement and it's usually relatively simple and just about one line to swap in each case. 48:48
But exactly what that line looks like differs a bit depending on the situation. 49:01
So there's actually like this whole large set of higher level TensorFlow wrappers that you might see out there in the wild. 49:06
And it seems that like even people within Google can't really agree on which one is the right one to use. 49:14
So Keras and TFLearn are third party libraries that are out there on the internet by other people. 49:22
But there's these three different ones, tf.layers, TF-Slim and tf.contrib.learn that all ship with TensorFlow, that are all kind of doing a slightly different version of this higher level wrapper thing. 49:26
There's another framework also from Google, but not shipping with TensorFlow called Pretty Tensor that does the same sort of thing. 49:39
And I guess none of these were good enough for DeepMind, because they went ahead a couple weeks ago and wrote and released their very own high level TensorFlow wrapper called Sonnet. 49:46
So I wouldn't begrudge you if you were kind of confused by all these things. 49:54
There's a lot of different choices. 49:59
They don't always play nicely with each other. 50:00
But you have a lot of options, so that's good. 50:03
TensorFlow has pretrained models. 50:07
There's some examples in TF-Slim, and in Keras. 50:09
'Cause remember retrained models are super important when you're training your own things. 50:11
There's also this idea of Tensorboard where you can load up your, I don't want to get into details, but Tensorboard you can add sort of instrumentation to your code and then plot losses and things as you go through the training process. 50:15
TensorFlow also let's you run distributed where you can break up a computational graph run on different machines. 50:27
That's super cool but I think probably not anyone outside of Google is really using that to great success these days, but if you do want to run distributed stuff probably TensorFlow is the main game in town for that. 50:32
A side note is that a lot of the design of TensorFlow is kind of spiritually inspired by this earlier framework called Theano from Montreal. 50:44
I don't want to go through the details here, just if you go through these slides on your own, you can see that the code for Theano ends up looking very similar to TensorFlow. 50:51
Where we define some variables, we do some forward pass, we compute some gradients, and we compile some function, then we run the function over and over to train the network. 50:59
So it kind of looks a lot like TensorFlow. 51:08
So we still have a lot to get through, so I'm going to move on to PyTorch and maybe take questions at the end. 51:10
So, PyTorch from Facebook is kind of different from TensorFlow in that we have sort of three explicit different layers of abstraction inside PyTorch. 51:16
So PyTorch has this tensor object which is just like a Numpy array. 51:26
It's just an imperative array, it doesn't know anything about deep learning, but it can run with GPU. 51:30
We have this variable object which is a node in a computational graph which builds up computational graphs, lets you compute gradients, that sort of thing. 51:36
And we have a module object which is a neural network layer that you can compose together these modules to build big networks. 51:44
So if you kind of want to think about rough equivalents between PyTorch and TensorFlow you can think of the PyTorch tensor as fulfilling the same role as the Numpy array in TensorFlow. 51:50
The PyTorch variable is similar to the TensorFlow tensor or variable or placeholder, which are all sort of nodes in a computational graph. 52:01
And now the PyTorch module is kind of equivalent to these higher level things from tf.slim or tf.layers or sonnet or these other higher level frameworks. 52:08
So right away one thing to notice about PyTorch is that because it ships with this high level abstraction and like one really nice higher level abstraction called modules on its own, there's sort of less choice involved. 52:18
Just stick with nnmodules and you'll be good to go. 52:29
You don't need to worry about which higher level wrapper to use. 52:32
So PyTorch tensors, as I said, are just like Numpy arrays so here on the right we've done an entire two layer network using entirely PyTorch tensors. 52:37
One thing to note is that we're not importing Numpy here at all anymore. 52:47
We're just doing all these operations using PyTorch tensors. 52:51
And this code looks exactly like the two layer net code that you wrote in Numpy on the first homework. 52:53
So you set up some random data, you use some operations to compute the forward pass. 53:01
And then we're explicitly viewing the backward pass ourself. 53:07
Just sort of backhopping through the network, through the operations, just as you did on homework one. 53:10
And now we're doing a manual update of the weights using a learning rate and using our computed gradients. 53:15
But the major difference between the PyTorch tensor and Numpy arrays is that they run on GPU so all you have to do to make this code run on GPU is use a different data type. 53:22
Rather than using torch.FloatTensor, you do torch.cuda.FloatTensor, cast all of your tensors to this new datatype and everything runs magically on the GPU. 53:33
You should think of PyTorch tensors as just Numpy plus GPU. 53:43
That's exactly what it is, nothing specific to deep learning. 53:47
So the next layer of abstraction in PyTorch is the variable. 53:52
So this is, once we moved from tensors to variables now we're building computational graphs and we're able to take gradients automatically and everything like that. 53:55
So here, if X is a variable, then x.data is a tensor and x.grad is another variable containing the gradients of the loss with respect to that tensor. 54:03
So x.grad.data is an actual tensor containing those gradients. 54:14
And PyTorch tensors and variables have the exact same API. 54:18
So any code that worked on PyTorch tensors you can just make them variables instead and run the same code, except now you're building up a computational graph rather than just doing these imperative operations. 54:22
So here when we create these variables each call to the variable constructor wraps a PyTorch tensor and then also gives a flag whether or not we want to compute gradients with respect to this variable. 54:35
And now in the forward pass it looks exactly like it did before in the variable in the case with tensors because they have the same API. 54:47
So now we're computing our predictions, we're computing our loss in kind of this imperative kind of way. 54:54
And then we call loss.backwards and now all these gradients come out for us. 54:59
And then we can make a gradient update step on our weights using the gradients that are now present in the w1.grad.data. 55:05
So this ends up looking quite like the Numpy case, except all the gradients come for free. 55:11
One thing to note that's kind of different between PyTorch and TensorFlow is that in a TensorFlow case we were building up this explicit graph, then running the graph many times. 55:18
Here in PyTorch, instead we're building up a new graph every time we do a forward pass. 55:27
And this makes the code look a bit cleaner. 55:32
And it has some other implications that we'll get to in a bit. 55:33
So in PyTorch you can define your own new autograd functions by defining the forward and backward in terms of tensors. 55:37
This ends up looking kind of like the module layers code that you write for homework two. 55:42
Where you can implement forward and backward using tensor operations and then stick these things inside computational graph. 55:48
So here we're defining our own relu and then we can actually go in and use our own relu operation and now stick it inside our computational graph and define our own operations this way. 55:54
But most of the time you will probably not need to define your own autograd operations. 56:05
Most of the times the operations you need will mostly be already implemented for you. 56:09
So in TensorFlow we saw, if we can move to something like Keras or TF.Learn and this gives us a higher level API to work with, rather than this raw computational graphs. 56:14
The equivalent in PyTorch is the nn package. 56:23
Where it provides these high level wrappers for working with these things. 56:25
But unlike TensorFlow there's only one of them. 56:31
And it works pretty well, so just use that if you're using PyTorch. 56:33
So here, this ends up kind of looking like Keras where we define our model as some sequence of layers. 56:37
Our linear and relu operations. 56:42
And we use some loss function defined in the nn package that's our mean squared error loss. 56:44
And now inside each iteration of our loop we can run data forward through the model to get our predictions. 56:49
We can run the predictions forward through the loss function to get our scale or loss, then we can call loss.backward, get all our gradients for free and then loop over the parameters of the models and do our explicit gradient descent step to update the models. 56:55
And again we see that we're sort of building up this new computational graph every time we do a forward pass. 57:07
And just like we saw in TensorFlow, PyTorch provides these optimizer operations that kind of abstract away this updating logic and implement fancier update rules like Adam and whatnot. 57:12
So here we're constructing an optimizer object telling it that we want it to optimize over the parameters of the model. 57:23
Giving it some learning rate under the hyper parameters. 57:28
And now after we compute our gradients we can just call optimizer.step and it updates all the parameters of the model for us right here. 57:31
So another common thing you'll do in PyTorch a lot is define your own nn modules. 57:39
So typically you'll write your own class which defines you entire model as a single new nn module class. 57:44
And a module is just kind of a neural network layer that can contain either other other modules or trainable weights or other other kinds of state. 57:51
So in this case we can redo the two layer net example by defining our own nn module class. 58:01
So now here in the initializer of the class we're assigning this linear1 and linear2. 58:07
We're constructing these new module objects and then store them inside of our own class. 58:11
And now in the forward pass we can use both our own internal modules as well as arbitrary autograd operations on variables to compute the output of our network. 58:17
So here we receive the, inside this forward method here, the input acts as a variable, then we pass the variable to our self.linear1 for the first layer. 58:26
We use an autograd op clamp to complete the relu, we pass the output of that to the second linear and then that gives us our output. 58:35
And now the rest of this code for training this thing looks pretty much the same. 58:42
Where we build an optimizer and loop over and on ever iteration feed data to the model, compute the gradients with loss.backwards, call optimizer.step. 58:46
So this is like relatively characteristic of what you might see in a lot of PyTorch type training scenarios. 58:54
Where you define your own class, defining your own model that contains other modules and whatnot and then you have some explicit training loop like this that runs it and updates it. 59:01
One kind of nice quality of life thing that you have in PyTorch is a dataloader. 59:11
So a dataloader can handle building minibatches for you. 59:16
It can handle some of the multi-threading that we talked about for you, where it can actually use multiple threads in the background to build many batches for you and stream off disk. 59:18
So here a dataloader wraps a dataset and provides some of these abstractions for you. 59:27
And in practice when you want to run your own data, you typically will write your own dataset class which knows how to read your particular type of data off whatever source you want and then wrap it in a data loader and train with that. 59:33
So, here we can see that now we're iterating over the dataloader object and at every iteration this is yielding minibatches of data. 59:44
And it's internally handling the shuffling of the data and multithreaded dataloading and all this sort of stuff for you. 59:52
So this is kind of a completely PyTorch example and a lot of PyTorch training code ends up looking something like this. 59:58
PyTorch provides pretrained models. 60:05
And this is probably the slickest pretrained model experience I've ever seen. 60:07
You just say torchvision.models.alexnet pretained=true. 60:11
That'll go down in the background, download the pretrained weights for you if you don't already have them, and then it's right there, you're good to go. 60:14
So this is super easy to use. 60:21
PyTorch also has, there's also a package called Visdom that lets you visualize some of these loss statistics somewhat similar to Tensorboard. 60:24
So that's kind of nice, I haven't actually gotten a chance to play around with this myself so I can't really speak to how useful it is, but one of the major differences between Tensorboard and Visdom is that Tensorboard actually lets you visualize the structure of the computational graph. 60:33
Which is really cool, a really useful debugging strategy. 60:45
And Visdom does not have that functionality yet. 60:47
But I've never really used this myself so I can't really speak to its utility. 60:50
As a bit of an aside, PyTorch is kind of an evolution of, kind of a newer updated version of an older framework called Torch which I worked with a lot in the last couple of years. 60:56
And I don't want to go through the details here, but PyTorch is pretty much better in a lot of ways than the old Lua Torch, but they actually share a lot of the same back end C code for computing with tensors and GPU operations on tensors and whatnot. 61:05
So if you look through this Torch example, some of it ends up looking kind of similar to PyTorch, some of it's a bit different. 61:18
Maybe you can step through this offline. 61:23
But kind of the high level differences between Torch and PyTorch are that Torch is actually in Lua, not Python, unlike these other things. 61:25
So learning Lua is a bit of a turn off for some people. 61:33
Torch doesn't have autograd. 61:37
Torch is also older, so it's more stable, less susceptible to bugs, there's maybe more example code for Torch. 61:40
They're about the same speeds, that's not really a concern. 61:45
But in PyTorch it's in Python which is great, you've got autograd which makes it a lot simpler to write complex models. 61:47
In Lua Torch you end up writing a lot of your own back prop code sometimes, so that's a little bit annoying. 61:54
But PyTorch is newer, there's less existing code, it's still subject to change. 61:59
So it's a little bit more of an adventure. 62:03
But at least for me, I kind of prefer, I don't really see much reason for myself to use Torch over PyTorch anymore at this time. 62:06
So I'm pretty much using PyTorch exclusively for all my work these days. 62:13
We talked about this a little bit about this idea of static versus dynamic graphs. 62:18
And this is one of the main distinguishing features between PyTorch and TensorFlow. 62:22
So we saw in TensorFlow you have these two stages of operation where first you build up this computational graph, then you run the computational graph over and over again many many times reusing that same graph. 62:26
That's called a static computational graph 'cause there's only one of them. 62:38
And we saw PyTorch is quite different where we're actually building up this new computational graph, this new fresh thing on every forward pass. 62:42
That's called a dynamic computational graph. 62:48
For kind of simple cases, with kind of feed forward neural networks, it doesn't really make a huge difference, the code ends up kind of similarly and they work kind of similarly, but I do want to talk a bit about some of the implications of static versus dynamic. 62:52
And what are the tradeoffs of those two. 63:04
So one kind of nice idea with static graphs is that because we're kind of building up one computational graph once, and then reusing it many times, the framework might have the opportunity to go in and do optimizations on that graph. 63:07
And kind of fuse some operations, reorder some operations, figure out the most efficient way to operate that graph so it can be really efficient. 63:19
And because we're going to reuse that graph many times, maybe that optimization process is expensive up front, but we can amortize that cost with the speedups that we've gotten when we run the graph many many times. 63:26
So as kind of a concrete example, maybe if you write some graph which has convolution and relu operations kind of one after another, you might imagine that some fancy graph optimizer could go in and actually output, like emit custom code which has fused operations, fusing the convolution and the relu so now it's computing the same thing as the code you wrote, but now might be able to be executed more efficiently. 63:37
So I'm not too sure on exactly what the state in practice of TensorFlow graph optimization is right now, but at least in principle, this is one place where static graph really, you can have the potential for doing this optimization in static graphs where maybe it would be not so tractable for dynamic graphs. 64:03
Another kind of subtle point about static versus dynamic is this idea of serialization. 64:25
So with a static graph you can imagine that you write this code that builds up the graph and then once you've built the graph, you have this data structure in memory that represents the entire structure of your network. 64:28
And now you could take that data structure and just serialize it to disk. 64:39
And now you've got the whole structure of your network saved in some file. 64:42
And then you could later rear load that thing and then run that computational graph without access to the original code that built it. 64:45
So this would be kind of nice in a deployment scenario. 64:53
You might imagine that you might want to train your network in Python because it's maybe easier to work with, but then after you serialize that network and then you could deploy it now in maybe a C++ environment where you don't need to use the original code that built the graph. 64:55
So that's kind of a nice advantage of static graphs. 65:07
Whereas with a dynamic graph, because we're interleaving these processes of graph building and graph execution, you kind of need the original code at all times if you want to reuse that model in the future. 65:10
On the other hand, some advantages for dynamic graphs are that it kind of makes, it just makes your code a lot cleaner and a lot easier in a lot of scenarios. 65:22
So for example, suppose that we want to do some conditional operation where depending on the value of some variable Z, we want to do different operations to compute Y. 65:29
Where if Z is positive, we want to use one weight matrix, if Z is negative we want to use a different weight matrix. 65:39
And we just want to switch off between these two alternatives. 65:45
In PyTorch because we're using dynamic graphs, it's super simple. 65:47
Your code kind of looks exactly like you would expect, exactly what you would do in Numpy. 65:52
You can just use normal Python control flow to handle this thing. 65:56
And now because we're building up the graph each time, each time we perform this operation will take one of the two paths and build up maybe a different graph on each forward pass, but for any graph that we do end up building up, we can back propagate through it just fine. 66:00
And the code is very clean, easy to work with. 66:14
Now in TensorFlow the situations is a little bit more complicated because we build the graph once, this control flow operator kind of needs to be an explicit operator in the TensorFlow graph. 66:15
And now, so them you can see that we have this tf.cond call which is kind of like a TensorFlow version of an if statement, but now it's baked into the computational graph rather than using sort of Python control flow. 66:28
And the problem is that because we only build the graph once, all the potential paths of control flow that our program might flow through need to be baked into the graph at the time we construct it before we ever run it. 66:40
So that means that any kind of control flow operators that you want to have need to be not Python control flow operators, you need to use some kind of magic, special tensor flow operations to do control flow. 66:52
In this case this tf.cond. 67:03
Another kind of similar situation happens if you want to have loops. 67:06
So suppose that we want to compute some kind of recurrent relationships where maybe Y T is equal to Y T minus one plus X T times some weight matrix W and depending on each time we do this, every time we compute this, we might have a different sized sequence of data. 67:10
And no matter the length of our sequence of data, we just want to compute this same recurrence relation no matter the size of the input sequence. 67:26
So in PyTorch this is super easy. 67:33
We can just kind of use a normal for loop in Python to just loop over the number of times that we want to unroll and now depending on the size of the input data, our computational graph will end up as different sizes, but that's fine, we can just back propagate through each one, one at a time. 67:35
Now in TensorFlow this becomes a little bit uglier. 67:51
And again, because we need to construct the graph all at once up front, this control flow looping construct again needs to be an explicit node in the TensorFlow graph. 67:55
So I hope you remember your functional programming because you'll have to use those kinds of operators to implement looping constructs in TensorFlow. 68:06
So in this case, for this particular recurrence relationship you can use a foldl operation and pass in, sort of implement this particular loop in terms of a foldl. 68:13
But what this basically means is that you have this sense that TensorFlow is almost building its own entire programming language, using the language of computational graphs. 68:24
And any kind of control flow operator, or any kind of data structure needs to be rolled into the computational graph so you can't really utilize all your favorite paradigms for working imperatively in Python. 68:33
You kind of need to relearn a whole separate set of control flow operators. 68:44
And if you want to do any kinds of control flow inside your computational graph using TensorFlow. 68:47
So at least for me, I find that kind of confusing, a little bit hard to wrap my head around sometimes, and I kind of like that using PyTorch dynamic graphs, you can just use your favorite imperative programming constructs and it all works just fine. 68:52
By the way, there actually is some very new library called TensorFlow Fold which is another one of these layers on top of TensorFlow that lets you implement dynamic graphs, you kind of write your own code using TensorFlow Fold that looks kind of like a dynamic graph operation and then TensorFlow Fold does some magic for you and somehow implements that in terms of the static TensorFlow graphs. 69:07
This is a super new paper that's being presented at ICLR this week in France. 69:32
So I haven't had the chance to like dive in and play with this yet. 69:37
But my initial impression was that it does add some amount of dynamic graphs to TensorFlow but it is still a bit more awkward to work with than the sort of native dynamic graphs you have in PyTorch. 69:41
So then, I thought it might be nice to motivate like why would we care about dynamic graphs in general? 69:51
So one option is recurrent networks. 69:57
So you can see that for something like image captioning we use a recurrent network which operates over sequences of different lengths. 70:01
In this case, the sentence that we want to generate as a caption is a sequence and that sequence can vary depending on our input data. 70:07
So now you can see that we have this dynamism in the thing where depending on the size of the sentence, our computational graph might need to have more or fewer elements. 70:15
So that's one kind of common application of dynamic graphs. 70:25
For those of you who took CS224N last quarter, you saw this idea of recursive networks where sometimes in natural language processing you might, for example, compute a parsed tree of a sentence and then you want to have a neural network kind of operate recursively up this parse tree. 70:29
So having a neural network that kind of works, it's not just a sequential sequence of layers, but instead it's kind of working over some graph or tree structure instead where now each data point might have a different graph or tree structure so the structure of the computational graph then kind of mirrors the structure of the input data. 70:47
And it could vary from data point to data point. 71:03
So this type of thing seems kind of complicated and hairy to implement using TensorFlow, but in PyTorch you can just kind of use like normal Python control flow and it'll work out just fine. 71:05
Another bit of more researchy application is this really cool idea that I like called neuromodule networks for visual question answering. 71:16
So here the idea is that we want to ask some questions about images where we maybe input this image of cats and dogs, there's some question, what color is the cat, and then internally the system can read the question and that has these different specialized neural network modules for performing operations like asking for colors and finding cats. 71:23
And then depending on the text of the question, it can compile this custom architecture for answering the question. 71:43
And now if we asked a different question, like are there more cats than dogs? 71:49
Now we have maybe the same basic set of modules for doing things like finding cats and dogs and counting, but they're arranged in a different order. 71:55
So we get this dynamism again where different data points might give rise to different computational graphs. 72:03
But this is a bit more of a researchy thing and maybe not so main stream right now. 72:07
But as kind of a bigger point, I think that there's a lot of cool, creative applications that people could do with dynamic computational graphs and maybe there aren't so many right now, just because it's been so painful to work with them. 72:12
So I think that there's a lot of opportunity for doing cool, creative things with dynamic computational graphs. 72:23
And maybe if you come up with cool ideas, we'll feature it in lecture next year. 72:30
So I wanted to talk very briefly about Caffe which is this framework from Berkeley. 72:34
Which Caffe is somewhat different from the other deep learning frameworks where you in many cases you can actually train networks without writing any code yourself. 72:39
You kind of just call into these pre-existing binaries, set up some configuration files and in many cases you can train on data without writing any of your own code. 72:48
So, you may be first, you convert your data into some format like HDF5 or LMDB and there exists some scripts inside Caffe that can just convert like folders of images and text files into these formats for you. 72:56
You need to define, now instead of writing code to define the structure of your computational graph, instead you edit some text file called a prototxt which sets up the structure of the computational graph. 73:08
Here the structure is that we read from some input HDF5 file, we perform some inner product, we compute some loss and the whole structure of the graph is set up in this text file. 73:19
One kind of downside here is that these files can get really ugly for very large networks. 73:30
So for something like the 152 layer ResNet model, which by the way was trained in Caffe originally, then this prototxt file ends up almost 7000 lines long. 73:35
So people are not writing these by hand. 73:44
People will sometimes will like write python scripts to generate these prototxt files. 73:47
[laughter] Then you're kind in the realm of rolling your own computational graph abstraction. 73:51
That's probably not a good idea, but I've seen that before. 73:56
Then, rather than having some optimizer object, instead there's some solver, you define some solver things inside another prototxt. 73:58
This defines your learning rate, your optimization algorithm and whatnot. 74:07
And then once you do all these things, you can just run the Caffe binary with the train command and it all happens magically. 74:11
Cafee has a model zoo with a bunch of pretrained models, that's pretty useful. 74:17
Caffe has a Python interface but it's not super well documented. 74:21
You kind of need to read the source code of the python interface to see what it can do, so that's kind of annoying. 74:25
But it does work. 74:30
So, kind of my general thing about Caffe is that it's maybe good for feed forward models, it's maybe good for production scenarios, because it doesn't depend on Python. 74:31
But probably for research these days, I've seen Caffe being used maybe a little bit less. 74:42
Although I think it is still pretty commonly used in industry again for production. 74:47
I promise one slide, one or two slides on Caffe 2. 74:51
So Caffe 2 is the successor to Caffe which is from Facebook. 74:54
It's super new, it was only released a week ago. 74:58
[laughter] So I really haven't had the time to form a super educated opinion about Caffe 2 yet, but it uses static graphs kind of similar to TensorFlow. 75:02
Kind of like Caffe one the core is written in C++ and they have some Python interface. 75:12
The difference is that now you no longer need to write your own Python scripts to generate prototxt files. 75:17
You can kind of define your computational graph structure all in Python, kind of looking with an API that looks kind of like TensorFlow. 75:21
But then you can spit out, you can serialize this computational graph structure to a prototxt file. 75:29
And then once your model is trained and whatnot, then we get this benefit that we talked about of static graphs where you can, you don't need the original training code now in order to deploy a trained model. 75:34
So one interesting thing is that you've seen Google maybe has one major deep running framework, which is TensorFlow, where Facebook has these two, PyTorch and Caffe 2. 75:43
So these are kind of different philosophies. 75:54
Google's kind of trying to build one framework to rule them all that maybe works for every possible scenario for deep learning. 75:57
This is kind of nice because it consolidates all efforts onto one framework. 76:02
It means you only need to learn one thing and it'll work across many different scenarios including like distributed systems, production, deployment, mobile, research, everything. 76:06
Only need to learn one framework to do all these things. 76:13
Whereas Facebook is taking a bit of a different approach. 76:15
Where PyTorch is really more specialized, more geared towards research so in terms of writing research code and quickly iterating on your ideas, that's super easy in PyTorch, but for things like running in production, running on mobile devices, PyTorch doesn't have a lot of great support. 76:18
Instead, Caffe 2 is kind of geared toward those more production oriented use cases. 76:32
So my kind of general study, my general, overall advice about like which framework to use for which problems is kind of that both, I think TensorFlow is a pretty safe bet for just about any project that you want to start new, right? 76:39
Because it is sort of one framework to rule them all, it can be used for just about any circumstance. 76:53
However, you probably need to pair it with a higher level wrapper and if you want dynamic graphs, you're maybe out of luck. 76:58
Some of the code ends up looking a little bit uglier in my opinion, but maybe that's kind of a cosmetic detail and it doesn't really matter that much. 77:05
I personally think PyTorch is really great for research. 77:13
If you're focused on just writing research code, I think PyTorch is a great choice. 77:15
But it's a bit newer, has less community support, less code out there, so it could be a bit of an adventure. 77:21
If you want more of a well trodden path, TensorFlow might be a better choice. 77:25
If you're interested in production deployment, you should probably look at Caffe, Caffe 2 or TensorFlow. 77:29
And if you're really focused on mobile deployment, I think TensorFlow and Caffe 2 both have some built in support for that. 77:34
So it's kind of unfortunately, there's not just like one global best framework, it kind of depends on what you're actually trying to do, what applications you anticipate but theses are kind of my general advice on those things. 77:41
So next time we'll talk about some case studies about various CNN architectures. 77:53
